{"version":3,"file":"lib/program.js","mappings":"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","sources":["webpack://@jsii/runtime/../../../node_modules/chownr/chownr.js","webpack://@jsii/runtime/../../../node_modules/fast-deep-equal/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/copy/copy-sync.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/copy/copy.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/copy/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/empty/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/ensure/file.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/ensure/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/ensure/link.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/ensure/symlink-type.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/ensure/symlink.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/fs/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/json/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/json/jsonfile.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/json/output-json-sync.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/json/output-json.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/mkdirs/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/mkdirs/make-dir.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/mkdirs/utils.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/move/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/move/move-sync.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/move/move.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/output-file/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/path-exists/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/remove/index.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/remove/rimraf.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/util/stat.js","webpack://@jsii/runtime/../../../node_modules/fs-extra/lib/util/utimes.js","webpack://@jsii/runtime/../../../node_modules/fs-minipass/index.js","webpack://@jsii/runtime/../../../node_modules/graceful-fs/clone.js","webpack://@jsii/runtime/../../../node_modules/graceful-fs/graceful-fs.js","webpack://@jsii/runtime/../../../node_modules/graceful-fs/legacy-streams.js","webpack://@jsii/runtime/../../../node_modules/graceful-fs/polyfills.js","webpack://@jsii/runtime/../../../node_modules/jsonfile/index.js","webpack://@jsii/runtime/../../../node_modules/jsonfile/utils.js","webpack://@jsii/runtime/../../../node_modules/lockfile/lockfile.js","webpack://@jsii/runtime/../../../node_modules/minipass/index.js","webpack://@jsii/runtime/../../../node_modules/minizlib/constants.js","webpack://@jsii/runtime/../../../node_modules/minizlib/index.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/index.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/lib/find-made.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/lib/mkdirp-manual.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/lib/mkdirp-native.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/lib/opts-arg.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/lib/path-arg.js","webpack://@jsii/runtime/../../../node_modules/mkdirp/lib/use-native.js","webpack://@jsii/runtime/../../../node_modules/signal-exit/index.js","webpack://@jsii/runtime/../../../node_modules/signal-exit/signals.js","webpack://@jsii/runtime/../../../node_modules/tar/index.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/create.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/extract.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/get-write-flag.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/header.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/high-level-opt.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/large-numbers.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/list.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/mkdir.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/mode-fix.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/normalize-unicode.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/normalize-windows-path.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/pack.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/parse.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/path-reservations.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/pax.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/read-entry.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/replace.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/strip-absolute-path.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/strip-trailing-slashes.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/types.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/unpack.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/update.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/warn-mixin.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/winchars.js","webpack://@jsii/runtime/../../../node_modules/tar/lib/write-entry.js","webpack://@jsii/runtime/../../../node_modules/universalify/index.js","webpack://@jsii/runtime/../../../node_modules/uri-js/src/util.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/regexps-uri.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/regexps-iri.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/node_modules/punycode/punycode.es6.js","webpack://@jsii/runtime/../../../node_modules/uri-js/src/uri.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/http.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/https.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/ws.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/wss.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/mailto.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/urn.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/schemes/urn-uuid.ts","webpack://@jsii/runtime/../../../node_modules/uri-js/src/index.ts","webpack://@jsii/runtime/../../../node_modules/yallist/iterator.js","webpack://@jsii/runtime/../../../node_modules/yallist/yallist.js","webpack://@jsii/runtime/../kernel/src/api.ts","webpack://@jsii/runtime/../kernel/src/disk-cache/digest-file.ts","webpack://@jsii/runtime/../kernel/src/disk-cache/disk-cache.ts","webpack://@jsii/runtime/../kernel/src/disk-cache/index.ts","webpack://@jsii/runtime/../kernel/src/index.ts","webpack://@jsii/runtime/../kernel/src/kernel.ts","webpack://@jsii/runtime/../kernel/src/link.ts","webpack://@jsii/runtime/../kernel/src/objects.ts","webpack://@jsii/runtime/../kernel/src/on-exit.ts","webpack://@jsii/runtime/../kernel/src/serialization.ts","webpack://@jsii/runtime/../kernel/src/tar-cache/default-cache-root.ts","webpack://@jsii/runtime/../kernel/src/tar-cache/index.ts","webpack://@jsii/runtime/./lib/host.ts","webpack://@jsii/runtime/./lib/in-out.ts","webpack://@jsii/runtime/./lib/sync-stdio.ts","webpack://@jsii/runtime/../spec/src/assembly-utils.ts","webpack://@jsii/runtime/../spec/src/assembly.ts","webpack://@jsii/runtime/../spec/src/index.ts","webpack://@jsii/runtime/../spec/src/name-tree.ts","webpack://@jsii/runtime/../spec/src/redirect.ts","webpack://@jsii/runtime/../spec/src/validate-assembly.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/ajv.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/codegen/code.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/codegen/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/codegen/scope.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/errors.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/names.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/ref_error.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/resolve.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/rules.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/util.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/applicability.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/boolSchema.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/dataType.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/defaults.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/keyword.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/compile/validate/subschema.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/core.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/runtime/equal.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/runtime/ucs2length.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/runtime/uri.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/runtime/validation_error.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/allOf.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/contains.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/if.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/items.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/items2020.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/not.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/properties.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/code.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/core/id.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/core/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/core/ref.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/discriminator/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/discriminator/types.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/draft7.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/format/format.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/format/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/metadata.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/const.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/enum.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/index.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/limitItems.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/limitLength.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/pattern.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/required.ts","webpack://@jsii/runtime/../spec/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","webpack://@jsii/runtime/../spec/node_modules/json-schema-traverse/index.js","webpack://@jsii/runtime/external node-commonjs \"assert\"","webpack://@jsii/runtime/external node-commonjs \"buffer\"","webpack://@jsii/runtime/external node-commonjs \"child_process\"","webpack://@jsii/runtime/external node-commonjs \"constants\"","webpack://@jsii/runtime/external node-commonjs \"crypto\"","webpack://@jsii/runtime/external node-commonjs \"events\"","webpack://@jsii/runtime/external node-commonjs \"fs\"","webpack://@jsii/runtime/external node-commonjs \"module\"","webpack://@jsii/runtime/external node-commonjs \"os\"","webpack://@jsii/runtime/external node-commonjs \"path\"","webpack://@jsii/runtime/external node-commonjs \"process\"","webpack://@jsii/runtime/external node-commonjs \"stream\"","webpack://@jsii/runtime/external node-commonjs \"string_decoder\"","webpack://@jsii/runtime/external node-commonjs \"util\"","webpack://@jsii/runtime/external node-commonjs \"zlib\"","webpack://@jsii/runtime/webpack/bootstrap","webpack://@jsii/runtime/./lib/program.ts"],"sourcesContent":["'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirs = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimesMillis = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  stat.checkPaths(src, dest, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return getStats(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return getStats(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))\n    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))\n    return cb(new Error(`Unknown file: ${src}`))\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy')),\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(async function emptyDir (dir) {\n  let items\n  try {\n    items = await fs.readdir(dir)\n  } catch {\n    return mkdir.mkdirs(dir)\n  }\n\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    fs.stat(dir, (err, stats) => {\n      if (err) {\n        // if the directory doesn't exist, make it\n        if (err.code === 'ENOENT') {\n          return mkdir.mkdirs(dir, err => {\n            if (err) return callback(err)\n            makeFile()\n          })\n        }\n        return callback(err)\n      }\n\n      if (stats.isDirectory()) makeFile()\n      else {\n        // parent is not a directory\n        // This is just to cause an internal ENOTDIR error to be thrown\n        fs.readdir(dir, err => {\n          if (err) return callback(err)\n        })\n      }\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst { createFile, createFileSync } = require('./file')\nconst { createLink, createLinkSync } = require('./link')\nconst { createSymlink, createSymlinkSync } = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile,\n  createFileSync,\n  ensureFile: createFile,\n  ensureFileSync: createFileSync,\n  // link\n  createLink,\n  createLinkSync,\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync,\n  // symlink\n  createSymlink,\n  createSymlinkSync,\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst { areIdentical } = require('../util/stat')\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  fs.lstat(dstpath, (_, dstStat) => {\n    fs.lstat(srcpath, (err, srcStat) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n      if (dstStat && areIdentical(srcStat, dstStat)) return callback(null)\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = fs.lstatSync(dstpath)\n  } catch {}\n\n  try {\n    const srcStat = fs.lstatSync(srcpath)\n    if (dstStat && areIdentical(srcStat, dstStat)) return\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('../fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nconst { areIdentical } = require('../util/stat')\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  fs.lstat(dstpath, (err, stats) => {\n    if (!err && stats.isSymbolicLink()) {\n      Promise.all([\n        fs.stat(srcpath),\n        fs.stat(dstpath)\n      ]).then(([srcStat, dstStat]) => {\n        if (areIdentical(srcStat, dstStat)) return callback(null)\n        _createSymlink(srcpath, dstpath, type, callback)\n      })\n    } else _createSymlink(srcpath, dstpath, type, callback)\n  })\n}\n\nfunction _createSymlink (srcpath, dstpath, type, callback) {\n  symlinkPaths(srcpath, dstpath, (err, relative) => {\n    if (err) return callback(err)\n    srcpath = relative.toDst\n    symlinkType(relative.toCwd, type, (err, type) => {\n      if (err) return callback(err)\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n        mkdirs(dir, err => {\n          if (err) return callback(err)\n          fs.symlink(srcpath, dstpath, type, callback)\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = fs.lstatSync(dstpath)\n  } catch {}\n  if (stats && stats.isSymbolicLink()) {\n    const srcStat = fs.statSync(srcpath)\n    const dstStat = fs.statSync(dstpath)\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rm',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.opendir was added in Node.js v12.12.0\n  // fs.rm was added in Node.js v14.14.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export cloned fs:\nObject.assign(exports, fs)\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.writev only available in Node v12.9.0+\nif (typeof fs.writev === 'function') {\n  // Function signature is\n  // s.writev(fd, buffers[, position], callback)\n  // We need to handle the optional arg, so we use ...args\n  exports.writev = function (fd, buffers, ...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      return fs.writev(fd, buffers, ...args)\n    }\n\n    return new Promise((resolve, reject) => {\n      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n        if (err) return reject(err)\n        resolve({ bytesWritten, buffers })\n      })\n    })\n  }\n}\n\n// fs.realpath.native sometimes not available if fs is monkey-patched\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n} else {\n  process.emitWarning(\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\n    'Warning', 'fs-extra-WARN0003'\n  )\n}\n","'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move'),\n  ...require('./output-file'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output-file')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output-file')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n","'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n","'use strict'\nconst fs = require('../fs')\nconst { checkPath } = require('./utils')\n\nconst getMode = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') return options\n  return ({ ...defaults, ...options }).mode\n}\n\nmodule.exports.makeDir = async (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdir(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n\nmodule.exports.makeDirSync = (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdirSync(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n","// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst path = require('path')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nmodule.exports.checkPath = function checkPath (pth) {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move')),\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase) {\n  if (isChangingCase) return rename(src, dest, overwrite)\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  opts = opts || {}\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, isChangingCase = false } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, isChangingCase, cb)\n      })\n    })\n  })\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase, cb) {\n  if (isChangingCase) return rename(src, dest, overwrite, cb)\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nfunction remove (path, callback) {\n  // Node 14.14.0+\n  if (fs.rm) return fs.rm(path, { recursive: true, force: true }, callback)\n  rimraf(path, callback)\n}\n\nfunction removeSync (path) {\n  // Node 14.14.0+\n  if (fs.rmSync) return fs.rmSync(path, { recursive: true, force: true })\n  rimraf.sync(path)\n}\n\nmodule.exports = {\n  remove: u(remove),\n  removeSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch {}\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis,\n  utimesMillisSync\n}\n","'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n","'use strict'\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: getPrototypeOf(obj) }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  var noReaddirOptionVersions = /^v[0-5]\\./\n  function readdir (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    var go$readdir = noReaddirOptionVersions.test(process.version)\n      ? function go$readdir (path, options, cb, startTime) {\n        return fs$readdir(path, fs$readdirCallback(\n          path, options, cb, startTime\n        ))\n      }\n      : function go$readdir (path, options, cb, startTime) {\n        return fs$readdir(path, options, fs$readdirCallback(\n          path, options, cb, startTime\n        ))\n      }\n\n    return go$readdir(path, options, cb)\n\n    function fs$readdirCallback (path, options, cb, startTime) {\n      return function (err, files) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([\n            go$readdir,\n            [path, options, cb],\n            err,\n            startTime || Date.now(),\n            Date.now()\n          ])\n        else {\n          if (files && files.sort)\n            files.sort()\n\n          if (typeof cb === 'function')\n            cb.call(this, err, files)\n        }\n      }\n    }\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we'll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don't\n    // bother modifying those since they'll be retried anyway.\n    if (fs[gracefulQueue][i].length > 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we're actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don't have a startTime we have no way of knowing if we've waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug('RETRY', fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime >= 60000) {\n    // it's been more than 60 seconds total, bail now\n    debug('TIMEOUT', fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === 'function')\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we've been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it's been long enough since the last retry, do it again\n    if (sinceAttempt >= desiredDelay) {\n      debug('RETRY', fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can't do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn't already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === 'function') {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (fs.chmod && !fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (fs.chown && !fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = typeof fs.rename !== 'function' ? fs.rename\n    : (function (fs$rename) {\n      function rename (from, to, cb) {\n        var start = Date.now()\n        var backoff = 0;\n        fs$rename(from, to, function CB (er) {\n          if (er\n              && (er.code === \"EACCES\" || er.code === \"EPERM\")\n              && Date.now() - start < 60000) {\n            setTimeout(function() {\n              fs.stat(to, function (stater, st) {\n                if (stater && stater.code === \"ENOENT\")\n                  fs$rename(from, to, CB);\n                else\n                  cb(er)\n              })\n            }, backoff)\n            if (backoff < 100)\n              backoff += 10;\n            return;\n          }\n          if (cb) cb(er)\n        })\n      }\n      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)\n      return rename\n    })(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = typeof fs.read !== 'function' ? fs.read\n  : (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync\n  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\") && fs.futimes) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else if (fs.futimes) {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats) {\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n      }\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n","function stringify (obj, { EOL = '\\n', finalEOL = true, replacer = null, spaces } = {}) {\n  const EOF = finalEOL ? EOL : ''\n  const str = JSON.stringify(obj, replacer, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOF\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n","var fs = require('fs')\n\nvar wx = 'wx'\nif (process.version.match(/^v0\\.[0-6]/)) {\n  var c = require('constants')\n  wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL\n}\n\nvar os = require('os')\nexports.filetime = 'ctime'\nif (os.platform() == \"win32\") {\n  exports.filetime = 'mtime'\n}\n\nvar debug\nvar util = require('util')\nif (util.debuglog)\n  debug = util.debuglog('LOCKFILE')\nelse if (/\\blockfile\\b/i.test(process.env.NODE_DEBUG))\n  debug = function() {\n    var msg = util.format.apply(util, arguments)\n    console.error('LOCKFILE %d %s', process.pid, msg)\n  }\nelse\n  debug = function() {}\n\nvar locks = {}\n\nfunction hasOwnProperty (obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\nvar onExit = require('signal-exit')\nonExit(function () {\n  debug('exit listener')\n  // cleanup\n  Object.keys(locks).forEach(exports.unlockSync)\n})\n\n// XXX https://github.com/joyent/node/issues/3555\n// Remove when node 0.8 is deprecated.\nif (/^v0\\.[0-8]\\./.test(process.version)) {\n  debug('uncaughtException, version = %s', process.version)\n  process.on('uncaughtException', function H (er) {\n    debug('uncaughtException')\n    var l = process.listeners('uncaughtException').filter(function (h) {\n      return h !== H\n    })\n    if (!l.length) {\n      // cleanup\n      try { Object.keys(locks).forEach(exports.unlockSync) } catch (e) {}\n      process.removeListener('uncaughtException', H)\n      throw er\n    }\n  })\n}\n\nexports.unlock = function (path, cb) {\n  debug('unlock', path)\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  delete locks[path]\n  fs.unlink(path, function (unlinkEr) { cb && cb() })\n}\n\nexports.unlockSync = function (path) {\n  debug('unlockSync', path)\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  try { fs.unlinkSync(path) } catch (er) {}\n  delete locks[path]\n}\n\n\n// if the file can be opened in readonly mode, then it's there.\n// if the error is something other than ENOENT, then it's not.\nexports.check = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {}\n  debug('check', path, opts)\n  fs.open(path, 'r', function (er, fd) {\n    if (er) {\n      if (er.code !== 'ENOENT') return cb(er)\n      return cb(null, false)\n    }\n\n    if (!opts.stale) {\n      return fs.close(fd, function (er) {\n        return cb(er, true)\n      })\n    }\n\n    fs.fstat(fd, function (er, st) {\n      if (er) return fs.close(fd, function (er2) {\n        return cb(er)\n      })\n\n      fs.close(fd, function (er) {\n        var age = Date.now() - st[exports.filetime].getTime()\n        return cb(er, age <= opts.stale)\n      })\n    })\n  })\n}\n\nexports.checkSync = function (path, opts) {\n  opts = opts || {}\n  debug('checkSync', path, opts)\n  if (opts.wait) {\n    throw new Error('opts.wait not supported sync for obvious reasons')\n  }\n\n  try {\n    var fd = fs.openSync(path, 'r')\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er\n    return false\n  }\n\n  if (!opts.stale) {\n    try { fs.closeSync(fd) } catch (er) {}\n    return true\n  }\n\n  // file exists.  however, might be stale\n  if (opts.stale) {\n    try {\n      var st = fs.fstatSync(fd)\n    } finally {\n      fs.closeSync(fd)\n    }\n    var age = Date.now() - st[exports.filetime].getTime()\n    return (age <= opts.stale)\n  }\n}\n\n\n\nvar req = 1\nexports.lock = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {}\n  opts.req = opts.req || req++\n  debug('lock', path, opts)\n  opts.start = opts.start || Date.now()\n\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    debug('has retries', opts.retries)\n    var retries = opts.retries\n    opts.retries = 0\n    cb = (function (orig) { return function cb (er, fd) {\n      debug('retry-mutated callback')\n      retries -= 1\n      if (!er || retries < 0) return orig(er, fd)\n\n      debug('lock retry', path, opts)\n\n      if (opts.retryWait) setTimeout(retry, opts.retryWait)\n      else retry()\n\n      function retry () {\n        opts.start = Date.now()\n        debug('retrying', opts.start)\n        exports.lock(path, opts, cb)\n      }\n    }})(cb)\n  }\n\n  // try to engage the lock.\n  // if this succeeds, then we're in business.\n  fs.open(path, wx, function (er, fd) {\n    if (!er) {\n      debug('locked', path, fd)\n      locks[path] = fd\n      return fs.close(fd, function () {\n        return cb()\n      })\n    }\n\n    debug('failed to acquire lock', er)\n\n    // something other than \"currently locked\"\n    // maybe eperm or something.\n    if (er.code !== 'EEXIST') {\n      debug('not EEXIST error', er)\n      return cb(er)\n    }\n\n    // someone's got this one.  see if it's valid.\n    if (!opts.stale) return notStale(er, path, opts, cb)\n\n    return maybeStale(er, path, opts, false, cb)\n  })\n  debug('lock return')\n}\n\n\n// Staleness checking algorithm\n// 1. acquire $lock, fail\n// 2. stat $lock, find that it is stale\n// 3. acquire $lock.STALE\n// 4. stat $lock, assert that it is still stale\n// 5. unlink $lock\n// 6. link $lock.STALE $lock\n// 7. unlink $lock.STALE\n// On any failure, clean up whatever we've done, and raise the error.\nfunction maybeStale (originalEr, path, opts, hasStaleLock, cb) {\n  fs.stat(path, function (statEr, st) {\n    if (statEr) {\n      if (statEr.code === 'ENOENT') {\n        // expired already!\n        opts.stale = false\n        debug('lock stale enoent retry', path, opts)\n        exports.lock(path, opts, cb)\n        return\n      }\n      return cb(statEr)\n    }\n\n    var age = Date.now() - st[exports.filetime].getTime()\n    if (age <= opts.stale) return notStale(originalEr, path, opts, cb)\n\n    debug('lock stale', path, opts)\n    if (hasStaleLock) {\n      exports.unlock(path, function (er) {\n        if (er) return cb(er)\n        debug('lock stale retry', path, opts)\n        fs.link(path + '.STALE', path, function (er) {\n          fs.unlink(path + '.STALE', function () {\n            // best effort.  if the unlink fails, oh well.\n            cb(er)\n          })\n        })\n      })\n    } else {\n      debug('acquire .STALE file lock', opts)\n      exports.lock(path + '.STALE', opts, function (er) {\n        if (er) return cb(er)\n        maybeStale(originalEr, path, opts, true, cb)\n      })\n    }\n  })\n}\n\nfunction notStale (er, path, opts, cb) {\n  debug('notStale', path, opts)\n\n  // if we can't wait, then just call it a failure\n  if (typeof opts.wait !== 'number' || opts.wait <= 0) {\n    debug('notStale, wait is not a number')\n    return cb(er)\n  }\n\n  // poll for some ms for the lock to clear\n  var now = Date.now()\n  var start = opts.start || now\n  var end = start + opts.wait\n\n  if (end <= now)\n    return cb(er)\n\n  debug('now=%d, wait until %d (delta=%d)', start, end, end-start)\n  var wait = Math.min(end - start, opts.pollPeriod || 100)\n  var timer = setTimeout(poll, wait)\n\n  function poll () {\n    debug('notStale, polling', path, opts)\n    exports.lock(path, opts, cb)\n  }\n}\n\nexports.lockSync = function (path, opts) {\n  opts = opts || {}\n  opts.req = opts.req || req++\n  debug('lockSync', path, opts)\n  if (opts.wait || opts.retryWait) {\n    throw new Error('opts.wait not supported sync for obvious reasons')\n  }\n\n  try {\n    var fd = fs.openSync(path, wx)\n    locks[path] = fd\n    try { fs.closeSync(fd) } catch (er) {}\n    debug('locked sync!', path, fd)\n    return\n  } catch (er) {\n    if (er.code !== 'EEXIST') return retryThrow(path, opts, er)\n\n    if (opts.stale) {\n      var st = fs.statSync(path)\n      var ct = st[exports.filetime].getTime()\n      if (!(ct % 1000) && (opts.stale % 1000)) {\n        // probably don't have subsecond resolution.\n        // round up the staleness indicator.\n        // Yes, this will be wrong 1/1000 times on platforms\n        // with subsecond stat precision, but that's acceptable\n        // in exchange for not mistakenly removing locks on\n        // most other systems.\n        opts.stale = 1000 * Math.ceil(opts.stale / 1000)\n      }\n      var age = Date.now() - ct\n      if (age > opts.stale) {\n        debug('lockSync stale', path, opts, age)\n        exports.unlockSync(path)\n        return exports.lockSync(path, opts)\n      }\n    }\n\n    // failed to lock!\n    debug('failed to lock', path, opts, er)\n    return retryThrow(path, opts, er)\n  }\n}\n\nfunction retryThrow (path, opts, er) {\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    var newRT = opts.retries - 1\n    debug('retryThrow', path, opts, newRT)\n    opts.retries = newRT\n    return exports.lockSync(path, opts)\n  }\n  throw er\n}\n\n","'use strict'\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = require('events')\nconst Stream = require('stream')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n","// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = require('zlib').constants ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n","'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n","const optsArg = require('./lib/opts-arg.js')\nconst pathArg = require('./lib/path-arg.js')\n\nconst {mkdirpNative, mkdirpNativeSync} = require('./lib/mkdirp-native.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./lib/mkdirp-manual.js')\nconst {useNative, useNativeSync} = require('./lib/use-native.js')\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n","const {dirname} = require('path')\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n","const {dirname} = require('path')\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n","const {dirname} = require('path')\nconst {findMade, findMadeSync} = require('./find-made.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./mkdirp-manual.js')\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n","const { promisify } = require('util')\nconst fs = require('fs')\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n","const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = require('path')\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n","const fs = require('fs')\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n","// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n}\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {}\n  }\n} else {\n  var assert = require('assert')\n  var signals = require('./signals.js')\n  var isWin = /^win/i.test(process.platform)\n\n  var EE = require('events')\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter\n  }\n\n  var emitter\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE()\n    emitter.count = 0\n    emitter.emitted = {}\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity)\n    emitter.infinite = true\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {}\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n    if (loaded === false) {\n      load()\n    }\n\n    var ev = 'exit'\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit'\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb)\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload()\n      }\n    }\n    emitter.on(ev, cb)\n\n    return remove\n  }\n\n  var unload = function unload () {\n    if (!loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = false\n\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    })\n    process.emit = originalProcessEmit\n    process.reallyExit = originalProcessReallyExit\n    emitter.count -= 1\n  }\n  module.exports.unload = unload\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true\n    emitter.emit(event, code, signal)\n  }\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {}\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig)\n      if (listeners.length === emitter.count) {\n        unload()\n        emit('exit', null, sig)\n        /* istanbul ignore next */\n        emit('afterexit', null, sig)\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT'\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig)\n      }\n    }\n  })\n\n  module.exports.signals = function () {\n    return signals\n  }\n\n  var loaded = false\n\n  var load = function load () {\n    if (loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1\n\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig])\n        return true\n      } catch (er) {\n        return false\n      }\n    })\n\n    process.emit = processEmit\n    process.reallyExit = processReallyExit\n  }\n  module.exports.load = load\n\n  var originalProcessReallyExit = process.reallyExit\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    process.exitCode = code || /* istanbul ignore next */ 0\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode)\n  }\n\n  var originalProcessEmit = process.emit\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg\n      }\n      var ret = originalProcessEmit.apply(this, arguments)\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null)\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null)\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  }\n}\n","// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n","'use strict'\n\n// high-level commands\nexports.c = exports.create = require('./lib/create.js')\nexports.r = exports.replace = require('./lib/replace.js')\nexports.t = exports.list = require('./lib/list.js')\nexports.u = exports.update = require('./lib/update.js')\nexports.x = exports.extract = require('./lib/extract.js')\n\n// classes\nexports.Pack = require('./lib/pack.js')\nexports.Unpack = require('./lib/unpack.js')\nexports.Parse = require('./lib/parse.js')\nexports.ReadEntry = require('./lib/read-entry.js')\nexports.WriteEntry = require('./lib/write-entry.js')\nexports.Header = require('./lib/header.js')\nexports.Pax = require('./lib/pax.js')\nexports.types = require('./lib/types.js')\n","'use strict'\n\n// tar -c\nconst hlo = require('./high-level-opt.js')\n\nconst Pack = require('./pack.js')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof files === 'function')\n    cb = files\n\n  if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else\n      p.add(file)\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n","'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n","// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = global.__FAKE_TESTING_FS__ || require('fs')\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n","'use strict'\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = require('./types.js')\nconst pathModule = require('path').posix\nconst large = require('./large-numbers.js')\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data))\n      this.decode(data, off || 0, ex, gex)\n    else if (data)\n      this.set(data)\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off)\n      off = 0\n\n    if (!buf || !(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '')\n      this[TYPE] = '0'\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/')\n      this[TYPE] = '5'\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5')\n      this.size = 0\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix)\n          this.path = prefix + '/' + this.path\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++)\n      sum += buf[i]\n\n    for (let i = off + 156; i < off + 512; i++)\n      sum += buf[i]\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20)\n      this.nullBlock = true\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off)\n      off = 0\n\n    if (!(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0)\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++)\n      sum += buf[i]\n\n    for (let i = off + 156; i < off + 512; i++)\n      sum += buf[i]\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (const i in data) {\n      if (data[i] !== null && data[i] !== undefined)\n        this[i] = data[i]\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type))\n      this[TYPE] = types.code.get(type)\n    else\n      this[TYPE] = type\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize)\n    ret = [pp, prefix, false]\n  else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp, prefix, false]\n\n      // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp.substr(0, pathSize - 1), prefix, true]\n\n      else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret)\n      ret = [p.substr(0, pathSize - 1), '', true]\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n  string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n","'use strict'\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow'],\n])\n\nmodule.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k],\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n","'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i - 1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i - 1] = 0\n    else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null)\n    throw Error('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n","'use strict'\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize)\n      p.end(fs.readFileSync(file))\n    else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n","'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\nconst normPath = require('./normalize-windows-path.js')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory())\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cSet(cache, dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return checkCwd(dir, done)\n\n  if (preserve)\n    return mkdirp(dir, {mode}).then(made => done(null, made), done)\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink) {\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok)\n      throw new CwdError(dir, code)\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n","'use strict'\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable)\n    mode = (mode | 0o600) & ~0o22\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400)\n      mode |= 0o100\n    if (mode & 0o40)\n      mode |= 0o10\n    if (mode & 0o4)\n      mode |= 0o1\n  }\n  return mode\n}\n","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null)\nconst {hasOwnProperty} = Object.prototype\nmodule.exports = s => {\n  if (!hasOwnProperty.call(normalizeCache, s))\n    normalizeCache[s] = s.normalize('NFKD')\n  return normalizeCache[s]\n}\n","// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n","'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      if (this.portable)\n        opt.gzip.portable = true\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n","'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null)\n      this[SAW_VALID_ENTRY] = false\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin')\n          this[STATE] = 'header'\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid)\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})\n      else if (!header.path)\n        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})\n      else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})\n        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})\n        else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid)\n                  this[SAW_VALID_ENTRY] = true\n              }\n              entry.on('end', onend)\n            } else\n              this[SAW_VALID_ENTRY] = true\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain)\n                this[STATE] = 'body'\n              else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else\n                this[QUEUE].push(entry)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, {entry})\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING])\n      this[BUFFERCONCAT](chunk)\n    else if (!chunk && !this[BUFFER])\n      this[MAYBEEND]()\n    else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else\n        this[CONSUMECHUNKSUB](chunk)\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n","// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\nconst normalize = require('./normalize-unicode.js')\nconst stripSlashes = require('./strip-trailing-slashes.js')\nconst { join } = require('path')\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length)\n        path = join(set[set.length - 1], path)\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res)\n      throw new Error('function does not have any path reservations')\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const {paths, dirs} = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn))\n      return false\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn))\n      return false\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1)\n        queues.delete(path)\n      else {\n        q.shift()\n        if (typeof q[0] === 'function')\n          next.add(q[0])\n        else\n          q[0].forEach(fn => next.add(fn))\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1)\n        queues.delete(dir)\n      else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else\n        q[0].delete(fn)\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return normalize(stripSlashes(join(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, {dirs, paths})\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q)\n        queues.set(path, [fn])\n      else\n        q.push(fn)\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q)\n        queues.set(dir, [new Set([fn])])\n      else if (q[q.length - 1] instanceof Set)\n        q[q.length - 1].add(fn)\n      else\n        q.push(new Set([fn]))\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n","'use strict'\nconst Header = require('./header.js')\nconst path = require('path')\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '')\n      return null\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++)\n      buf[i] = 0\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++)\n      buf[i] = 0\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined)\n      return ''\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n        ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits))\n      digits += 1\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1)\n    return set\n\n  line = line.substr((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k)\n    return set\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ? new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n","'use strict'\nconst MiniPass = require('minipass')\nconst normPath = require('./normalize-windows-path.js')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex)\n      this[SLURP](ex)\n    if (gex)\n      this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n    }\n  }\n}\n","'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return fs.close(fd, () => reject(er))\n\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else\n      p.add(file)\n  }\n  p.end()\n}\n","// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = require('path').win32\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.substr(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nmodule.exports = str => {\n  let i = str.length - 1\n  let slashesStart = -1\n  while (i > -1 && str.charAt(i) === '/') {\n    slashesStart = i\n    i--\n  }\n  return slashesStart === -1 ? str : str.slice(0, slashesStart)\n}\n","'use strict'\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader'],\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n","'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\nconst normalize = require('./normalize-unicode.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows)\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows)\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => normalize(stripSlash(normPath(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0)\n      cache.delete(path)\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys())\n    cache.delete(key)\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT')\n      data.recoverable = false\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        else\n          return false\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = normPath(path.resolve(entry.path))\n    else\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir')\n      return false\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn('TAR_ENTRY_ERROR', er, {entry})\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd)\n        fs.close(stream.fd, () => {})\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd)\n          fs.close(stream.fd, () => {})\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er)\n            this[ONERROR](er, entry)\n          else\n            this[UNPEND]()\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, {entry})\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink')\n      dropCache(this.dirCache)\n    else if (entry.type !== 'Directory')\n      pruneCache(this.dirCache, entry.absolute)\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st))\n          return this[MAKEFS](null, entry, done)\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod)\n              return afterChmod()\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd)\n          return this[MAKEFS](null, entry, done)\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD])\n      start()\n    else\n      checkCwd()\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        this[ONERROR](er, entry)\n      else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er)\n        return this[ONERROR](er, entry)\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent)\n          return this[ONERROR](mkParent, entry)\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime))\n      return this[SKIP](entry)\n\n    if (lstatEr || this[ISREUSABLE](entry, st))\n      return this[MAKEFS](null, entry)\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n","'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n","'use strict'\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file)\n      data.file = this.file\n    if (this.cwd)\n      data.cwd = this.cwd\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error)\n      this.emit('error', Object.assign(message, data))\n    else\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n  }\n}\n","'use strict'\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':',\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),\n}\n","'use strict'\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix)\n    return normPath(path)\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '')\n      this.path = './'\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error')\n      this[HAD_ERROR] = true\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR])\n      return this[CLOSE]()\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed)\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    else\n      this[ONDRAIN]()\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain)\n        super.write(Buffer.alloc(this.blockRemain))\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      super.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.call(\n          this,\n          ...args,\n          (err, res) => (err != null) ? reject(err) : resolve(res)\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","export const TOKEN_REF = '$jsii.byref';\nexport const TOKEN_INTERFACES = '$jsii.interfaces';\nexport const TOKEN_DATE = '$jsii.date';\nexport const TOKEN_ENUM = '$jsii.enum';\nexport const TOKEN_MAP = '$jsii.map';\nexport const TOKEN_STRUCT = '$jsii.struct';\n\nexport interface ObjRef {\n  readonly [TOKEN_REF]: string;\n  [TOKEN_INTERFACES]?: readonly string[];\n}\n\nexport function isObjRef(value: any): value is ObjRef {\n  return typeof value === 'object' && value !== null && TOKEN_REF in value;\n}\n\nexport interface WireDate {\n  readonly [TOKEN_DATE]: string;\n}\n\nexport function isWireDate(value: any): value is WireDate {\n  return typeof value === 'object' && value !== null && TOKEN_DATE in value;\n}\n\nexport interface WireEnum {\n  readonly [TOKEN_ENUM]: string;\n}\n\nexport function isWireEnum(value: any): value is WireEnum {\n  return typeof value === 'object' && value !== null && TOKEN_ENUM in value;\n}\n\nexport interface WireMap {\n  readonly [TOKEN_MAP]: { readonly [key: string]: any };\n}\n\nexport function isWireMap(value: any): value is WireMap {\n  return typeof value === 'object' && value !== null && TOKEN_MAP in value;\n}\n\nexport interface WireStruct {\n  readonly [TOKEN_STRUCT]: {\n    readonly fqn: string;\n    readonly data: { [key: string]: any };\n  };\n}\n\nexport function isWireStruct(value: any): value is WireStruct {\n  return typeof value === 'object' && value !== null && TOKEN_STRUCT in value;\n}\n\nexport type Override = MethodOverride | PropertyOverride;\n\nexport interface MethodOverride {\n  readonly method: string;\n  readonly cookie?: string;\n}\n\nexport function isMethodOverride(value: Override): value is MethodOverride {\n  return (value as any).method != null; // Python passes \"null\"\n}\n\nexport interface PropertyOverride {\n  readonly property: string;\n  readonly cookie?: string;\n}\n\nexport function isPropertyOverride(value: Override): value is PropertyOverride {\n  return (value as any).property != null; // Python passes \"null\"\n}\n\nexport interface Callback {\n  readonly cbid: string;\n  readonly cookie: string | undefined;\n  readonly invoke?: InvokeRequest;\n  readonly get?: GetRequest;\n  readonly set?: SetRequest;\n}\n\nexport interface HelloResponse {\n  readonly hello: string;\n}\n\nexport interface LoadRequest {\n  /** The name of the assembly */\n  readonly name: string;\n\n  /** Assembly version */\n  readonly version: string;\n\n  /** The tarball of the package */\n  readonly tarball: string;\n}\n\nexport interface LoadResponse {\n  readonly assembly: string;\n  readonly types: number;\n}\n\nexport interface InvokeScriptRequest {\n  readonly assembly: string;\n  readonly script: string;\n  readonly args?: string[];\n}\n\nexport interface InvokeScriptResponse {\n  readonly status: number | null;\n  readonly stdout: string;\n  readonly stderr: string;\n  readonly signal: string | null;\n}\n\nexport interface CreateRequest {\n  /**\n   * The FQN of the class of which an instance is requested (or \"Object\")\n   */\n  readonly fqn: string;\n\n  /**\n   * The FQNs of interfaces the instance implements, if any. Declaring\n   * interfaces that the class denoted by `fqn` implements is not necessary.\n   * This means that memebers of interfaces found in this property should\n   * declare members that are found in the `overrides` property.\n   */\n  readonly interfaces?: string[];\n\n  /**\n   * Arguments to pass to the constructor of `fqn`. (\"Object\" accepts none)\n   */\n  readonly args?: any[];\n\n  /**\n   * Declarations of method overrides that should trigger callbacks\n   */\n  readonly overrides?: Override[];\n}\n\nexport type CreateResponse = ObjRef;\n\nexport interface DelRequest {\n  readonly objref: ObjRef;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface DelResponse {}\n\nexport interface GetRequest {\n  readonly objref: ObjRef;\n  readonly property: string;\n}\n\nexport interface StaticGetRequest {\n  readonly fqn: string;\n  readonly property: string;\n}\n\nexport interface GetResponse {\n  readonly value: any;\n}\n\nexport interface StaticSetRequest {\n  readonly fqn: string;\n  readonly property: string;\n  readonly value: any;\n}\n\nexport interface SetRequest {\n  readonly objref: ObjRef;\n  readonly property: string;\n  readonly value: any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface SetResponse {}\n\nexport interface StaticInvokeRequest {\n  readonly fqn: string;\n  readonly method: string;\n  readonly args?: any[];\n}\n\nexport interface InvokeRequest {\n  readonly objref: ObjRef;\n  readonly method: string;\n  readonly args?: any[];\n}\n\nexport interface InvokeResponse {\n  readonly result: any;\n}\n\nexport interface BeginRequest {\n  readonly objref: ObjRef;\n  readonly method: string;\n  readonly args?: any[];\n}\n\nexport interface BeginResponse {\n  readonly promiseid: string;\n}\n\nexport interface EndRequest {\n  readonly promiseid: string;\n}\n\nexport interface EndResponse {\n  readonly result: any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CallbacksRequest {}\n\nexport interface CallbacksResponse {\n  readonly callbacks: Callback[];\n}\n\nexport interface CompleteRequest {\n  readonly cbid: string;\n  readonly err?: string;\n  readonly result?: any;\n}\n\nexport interface CompleteResponse {\n  readonly cbid: string;\n}\n\nexport interface NamingRequest {\n  readonly assembly: string;\n}\n\nexport interface NamingResponse {\n  readonly naming: {\n    readonly [language: string]: { readonly [key: string]: any } | undefined;\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface StatsRequest {}\n\nexport interface StatsResponse {\n  readonly objectCount: number;\n}\n\nexport type KernelRequest =\n  | LoadRequest\n  | CreateRequest\n  | DelRequest\n  | GetRequest\n  | SetRequest\n  | InvokeRequest\n  | BeginRequest\n  | EndRequest\n  | CallbacksRequest\n  | CompleteRequest\n  | NamingRequest\n  | StatsRequest;\n\nexport type KernelResponse =\n  | HelloResponse\n  | LoadResponse\n  | CreateResponse\n  | DelResponse\n  | GetResponse\n  | SetResponse\n  | InvokeResponse\n  | BeginResponse\n  | EndResponse\n  | CallbacksResponse\n  | CompleteResponse\n  | NamingResponse\n  | StatsResponse;\n\nexport interface OkayResponse {\n  readonly ok: any;\n}\n\nexport interface ErrorResponse {\n  readonly error: string;\n  readonly stack?: string;\n}\n","import { createHash } from 'crypto';\nimport { openSync, readSync, closeSync } from 'fs';\n\nconst ALGORITHM = 'sha256';\n\nexport function digestFile(\n  path: string,\n  ...comments: readonly string[]\n): Buffer {\n  const hash = createHash(ALGORITHM);\n\n  const buffer = Buffer.alloc(16_384);\n  const fd = openSync(path, 'r');\n  try {\n    let bytesRead = 0;\n    while ((bytesRead = readSync(fd, buffer)) > 0) {\n      hash.update(buffer.slice(0, bytesRead));\n    }\n    for (const comment of comments) {\n      hash.update('\\0');\n      hash.update(comment);\n    }\n    return hash.digest();\n  } finally {\n    closeSync(fd);\n  }\n}\n","import {\n  existsSync,\n  mkdirSync,\n  readdirSync,\n  readFileSync,\n  realpathSync,\n  rmdirSync,\n  rmSync,\n  statSync,\n  utimesSync,\n  writeFileSync,\n} from 'fs';\nimport { lockSync, unlockSync } from 'lockfile';\nimport { dirname, join } from 'path';\n\nimport { digestFile } from './digest-file';\n\nconst MARKER_FILE_NAME = '.jsii-runtime-package-cache';\n\nconst ONE_DAY_IN_MS = 86_400_000;\nconst PRUNE_AFTER_MILLISECONDS = process.env.JSII_RUNTIME_PACKAGE_CACHE_TTL\n  ? parseInt(process.env.JSII_RUNTIME_PACKAGE_CACHE_TTL, 10) * ONE_DAY_IN_MS\n  : 30 * ONE_DAY_IN_MS;\n\nexport class DiskCache {\n  private static readonly CACHE = new Map<string, DiskCache>();\n\n  public static inDirectory(path: string): DiskCache {\n    const didCreate = mkdirSync(path, { recursive: true }) != null;\n    if (didCreate && process.platform === 'darwin') {\n      // Mark the directories for no iCloud sync, no Spotlight indexing, no TimeMachine backup\n      // @see https://michaelbach.de/2019/03/19/MacOS-nosync-noindex-nobackup.html\n      writeFileSync(join(path, '.nobackup'), '');\n      writeFileSync(join(path, '.noindex'), '');\n      writeFileSync(join(path, '.nosync'), '');\n    }\n\n    path = realpathSync(path);\n    if (!this.CACHE.has(path)) {\n      this.CACHE.set(path, new DiskCache(path));\n    }\n    return this.CACHE.get(path)!;\n  }\n\n  readonly #root: string;\n\n  private constructor(root: string) {\n    this.#root = root;\n    process.once('beforeExit', () => this.pruneExpiredEntries());\n  }\n\n  public entry(...key: readonly string[]): Entry {\n    if (key.length === 0) {\n      throw new Error(`Cache entry key must contain at least 1 element!`);\n    }\n\n    return new Entry(\n      join(\n        this.#root,\n        ...key.flatMap((s) =>\n          s\n            .replace(/[^@a-z0-9_.\\\\/-]+/g, '_')\n            .split(/[\\\\/]+/)\n            .map((ss) => {\n              if (ss === '..') {\n                throw new Error(\n                  `A cache entry key cannot contain a '..' path segment! (${s})`,\n                );\n              }\n              return ss;\n            }),\n        ),\n      ),\n    );\n  }\n\n  public entryFor(path: string, ...comments: readonly string[]): Entry {\n    const rawDigest = digestFile(path, ...comments);\n    return this.entry(...comments, rawDigest.toString('hex'));\n  }\n\n  public pruneExpiredEntries() {\n    const cutOff = new Date(Date.now() - PRUNE_AFTER_MILLISECONDS);\n    for (const entry of this.entries()) {\n      if (entry.atime < cutOff) {\n        entry.lock((lockedEntry) => {\n          // Check again in case it's been accessed which we waited for the lock...\n          if (entry.atime > cutOff) {\n            return;\n          }\n          lockedEntry.delete();\n        });\n      }\n    }\n\n    for (const dir of directoriesUnder(this.#root, true)) {\n      if (process.platform === 'darwin') {\n        try {\n          rmSync(join(dir, '.DS_Store'), { force: true });\n        } catch {\n          // Ignore errors...\n        }\n      }\n      if (readdirSync(dir).length === 0) {\n        try {\n          rmdirSync(dir);\n        } catch {\n          // Ignore errors, directory may no longer be empty...\n        }\n      }\n    }\n  }\n\n  private *entries(): Generator<Entry, void, void> {\n    yield* inDirectory(this.#root);\n\n    function* inDirectory(dir: string): Generator<Entry, void, void> {\n      if (existsSync(join(dir, MARKER_FILE_NAME))) {\n        return yield new Entry(dir);\n      }\n      for (const file of directoriesUnder(dir)) {\n        yield* inDirectory(file);\n      }\n    }\n  }\n}\n\nexport class Entry {\n  public constructor(public readonly path: string) {}\n\n  public get atime(): Date {\n    try {\n      const stat = statSync(this.markerFile);\n      return stat.atime;\n    } catch (err: any) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n      return new Date(0);\n    }\n  }\n\n  public get pathExists() {\n    return existsSync(this.path);\n  }\n\n  private get lockFile(): string {\n    return `${this.path}.lock`;\n  }\n\n  private get markerFile(): string {\n    return join(this.path, MARKER_FILE_NAME);\n  }\n\n  public lock<T>(cb: (entry: LockedEntry) => T): T {\n    mkdirSync(dirname(this.path), { recursive: true });\n    lockSync(this.lockFile, { retries: 12, stale: 5_000 });\n    let disposed = false;\n    try {\n      return cb({\n        delete: () => {\n          if (disposed) {\n            throw new Error(\n              `Cannot delete ${this.path} once the lock block was returned!`,\n            );\n          }\n          rmSync(this.path, { force: true, recursive: true });\n        },\n        write: (name, content) => {\n          if (disposed) {\n            throw new Error(\n              `Cannot write ${join(\n                this.path,\n                name,\n              )} once the lock block was returned!`,\n            );\n          }\n\n          mkdirSync(dirname(join(this.path, name)), { recursive: true });\n          writeFileSync(join(this.path, name), content);\n        },\n        touch: () => {\n          if (disposed) {\n            throw new Error(\n              `Cannot touch ${this.path} once the lock block was returned!`,\n            );\n          }\n          if (this.pathExists) {\n            if (existsSync(this.markerFile)) {\n              const now = new Date();\n              utimesSync(this.markerFile, now, now);\n            } else {\n              writeFileSync(this.markerFile, '');\n            }\n          }\n        },\n      });\n    } finally {\n      disposed = true;\n      unlockSync(this.lockFile);\n    }\n  }\n\n  public read(file: string): Buffer | undefined {\n    try {\n      return readFileSync(join(this.path, file));\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n}\n\nexport interface LockedEntry {\n  delete(): void;\n  write(name: string, data: Buffer): void;\n\n  touch(): void;\n}\n\nfunction* directoriesUnder(\n  root: string,\n  recursive = false,\n  ignoreErrors = true,\n): Generator<string, void, void> {\n  for (const file of readdirSync(root)) {\n    const path = join(root, file);\n    try {\n      const stat = statSync(path);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          yield* directoriesUnder(path, recursive, ignoreErrors);\n        }\n        yield path;\n      }\n    } catch (error) {\n      if (!ignoreErrors) {\n        throw error;\n      }\n    }\n  }\n}\n","export * from './disk-cache';\n","export * from './kernel';\n\nimport * as api from './api';\nexport { api };\n","import * as spec from '@jsii/spec';\nimport { loadAssemblyFromPath } from '@jsii/spec';\nimport * as cp from 'child_process';\nimport { renameSync } from 'fs';\nimport * as fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport * as os from 'os';\nimport * as path from 'path';\n\nimport * as api from './api';\nimport { TOKEN_REF } from './api';\nimport { link } from './link';\nimport { jsiiTypeFqn, ObjectTable, tagJsiiConstructor } from './objects';\nimport * as onExit from './on-exit';\nimport * as wire from './serialization';\nimport * as tar from './tar-cache';\n\nexport class Kernel {\n  /**\n   * Set to true for verbose debugging.\n   */\n  public traceEnabled = false;\n  /**\n   * Set to true for timing data to be emitted.\n   */\n  public debugTimingEnabled = false;\n\n  private readonly assemblies = new Map<string, Assembly>();\n  private readonly objects = new ObjectTable(this._typeInfoForFqn.bind(this));\n  private readonly cbs = new Map<string, Callback>();\n  private readonly waiting = new Map<string, Callback>();\n  private readonly promises = new Map<string, AsyncInvocation>();\n  private nextid = 20000; // incrementing counter for objid, cbid, promiseid\n  private syncInProgress?: string; // forbids async calls (begin) while processing sync calls (get/set/invoke)\n  private installDir?: string;\n  /** The internal require function, used instead of the global \"require\" so that webpack does not transform it... */\n  private require?: typeof require;\n\n  /**\n   * Creates a jsii kernel object.\n   *\n   * @param callbackHandler This handler is invoked when a synchronous callback is called.\n   *                        It's responsibility is to execute the callback and return it's\n   *                        result (or throw an error).\n   */\n  public constructor(public callbackHandler: (callback: api.Callback) => any) {}\n\n  public load(req: api.LoadRequest): api.LoadResponse {\n    return this._debugTime(\n      () => this._load(req),\n      `load(${JSON.stringify(req, null, 2)})`,\n    );\n  }\n\n  private _load(req: api.LoadRequest): api.LoadResponse {\n    this._debug('load', req);\n\n    if ('assembly' in req) {\n      throw new Error(\n        '`assembly` field is deprecated for \"load\", use `name`, `version` and `tarball` instead',\n      );\n    }\n\n    const pkgname = req.name;\n    const pkgver = req.version;\n\n    // check if we already have such a module\n    const packageDir = this._getPackageDir(pkgname);\n    if (fs.pathExistsSync(packageDir)) {\n      // module exists, verify version\n      const epkg = fs.readJsonSync(path.join(packageDir, 'package.json'));\n      if (epkg.version !== pkgver) {\n        throw new Error(\n          `Multiple versions ${pkgver} and ${epkg.version} of the ` +\n            `package '${pkgname}' cannot be loaded together since this is unsupported by ` +\n            'some runtime environments',\n        );\n      }\n\n      // same version, no-op\n      this._debug('look up already-loaded assembly', pkgname);\n      const assm = this.assemblies.get(pkgname)!;\n\n      return {\n        assembly: assm.metadata.name,\n        types: Object.keys(assm.metadata.types ?? {}).length,\n      };\n    }\n\n    // Force umask to have npm-install-like permissions\n    const originalUmask = process.umask(0o022);\n    try {\n      // untar the archive to its final location\n      const { path: extractedTo, cache } = this._debugTime(\n        () =>\n          tar.extract(\n            req.tarball,\n            {\n              strict: true,\n              strip: 1, // Removes the 'package/' path element from entries\n              unlink: true,\n            },\n            req.name,\n            req.version,\n          ),\n        `tar.extract(${req.tarball}) => ${packageDir}`,\n      );\n\n      // Create the install directory (there may be several path components for @scoped/packages)\n      fs.mkdirSync(path.dirname(packageDir), { recursive: true });\n      if (cache != null) {\n        this._debug(\n          `Package cache enabled, extraction resulted in a cache ${cache}`,\n        );\n\n        // Link the package into place.\n        this._debugTime(\n          () => link(extractedTo, packageDir),\n          `link(${extractedTo}, ${packageDir})`,\n        );\n      } else {\n        // This is not from cache, so we move it around instead of copying.\n        renameSync(extractedTo, packageDir);\n      }\n    } finally {\n      // Reset umask to the initial value\n      process.umask(originalUmask);\n    }\n\n    // read .jsii metadata from the root of the package\n    let assmSpec;\n    try {\n      assmSpec = this._debugTime(\n        () => loadAssemblyFromPath(packageDir),\n        `loadAssemblyFromPath(${packageDir})`,\n      );\n    } catch (e: any) {\n      throw new Error(`Error for package tarball ${req.tarball}: ${e.message}`);\n    }\n\n    // load the module and capture its closure\n    const closure = this._debugTime(\n      () => this.require!(packageDir),\n      `require(${packageDir})`,\n    );\n    const assm = new Assembly(assmSpec, closure);\n    this._debugTime(\n      () => this._addAssembly(assm),\n      `registerAssembly({ name: ${assm.metadata.name}, types: ${\n        Object.keys(assm.metadata.types ?? {}).length\n      } })`,\n    );\n\n    return {\n      assembly: assmSpec.name,\n      types: Object.keys(assmSpec.types ?? {}).length,\n    };\n  }\n\n  public invokeBinScript(\n    req: api.InvokeScriptRequest,\n  ): api.InvokeScriptResponse {\n    const packageDir = this._getPackageDir(req.assembly);\n    if (fs.pathExistsSync(packageDir)) {\n      // module exists, verify version\n      const epkg = fs.readJsonSync(path.join(packageDir, 'package.json'));\n\n      if (!epkg.bin) {\n        throw new Error('There is no bin scripts defined for this package.');\n      }\n\n      const scriptPath = epkg.bin[req.script];\n\n      if (!epkg.bin) {\n        throw new Error(`Script with name ${req.script} was not defined.`);\n      }\n\n      const result = cp.spawnSync(\n        path.join(packageDir, scriptPath),\n        req.args ?? [],\n        {\n          encoding: 'utf-8',\n          env: {\n            ...process.env,\n            // Make sure the current NODE_OPTIONS are honored if we shell out to node\n            NODE_OPTIONS: process.execArgv.join(' '),\n            // Make sure \"this\" node is ahead of $PATH just in case\n            PATH: `${path.dirname(process.execPath)}:${process.env.PATH}`,\n          },\n          shell: true,\n        },\n      );\n\n      return {\n        stdout: result.stdout,\n        stderr: result.stderr,\n        status: result.status,\n        signal: result.signal,\n      };\n    }\n    throw new Error(`Package with name ${req.assembly} was not loaded.`);\n  }\n\n  public create(req: api.CreateRequest): api.CreateResponse {\n    return this._create(req);\n  }\n\n  public del(req: api.DelRequest): api.DelResponse {\n    const { objref } = req;\n\n    this._debug('del', objref);\n    this.objects.deleteObject(objref);\n\n    return {};\n  }\n\n  public sget(req: api.StaticGetRequest): api.GetResponse {\n    const { fqn, property } = req;\n    const symbol = `${fqn}.${property}`;\n    this._debug('sget', symbol);\n    const ti = this._typeInfoForProperty(property, fqn);\n\n    if (!ti.static) {\n      throw new Error(`property ${symbol} is not static`);\n    }\n\n    const prototype = this._findSymbol(fqn);\n\n    const value = this._ensureSync(\n      `property ${property}`,\n      () => prototype[property],\n    );\n\n    this._debug('value:', value);\n    const ret = this._fromSandbox(value, ti, `of static property ${symbol}`);\n    this._debug('ret', ret);\n    return { value: ret };\n  }\n\n  public sset(req: api.StaticSetRequest): api.SetResponse {\n    const { fqn, property, value } = req;\n    const symbol = `${fqn}.${property}`;\n    this._debug('sset', symbol);\n    const ti = this._typeInfoForProperty(property, fqn);\n\n    if (!ti.static) {\n      throw new Error(`property ${symbol} is not static`);\n    }\n\n    if (ti.immutable) {\n      throw new Error(`static property ${symbol} is readonly`);\n    }\n\n    const prototype = this._findSymbol(fqn);\n\n    this._ensureSync(\n      `property ${property}`,\n      () =>\n        (prototype[property] = this._toSandbox(\n          value,\n          ti,\n          `assigned to static property ${symbol}`,\n        )),\n    );\n\n    return {};\n  }\n\n  public get(req: api.GetRequest): api.GetResponse {\n    const { objref, property } = req;\n    this._debug('get', objref, property);\n    const { instance, fqn, interfaces } = this.objects.findObject(objref);\n    const ti = this._typeInfoForProperty(property, fqn, interfaces);\n\n    // if the property is overridden by the native code and \"get\" is called on the object, it\n    // means that the native code is trying to access the \"super\" property. in order to enable\n    // that, we actually keep a copy of the original property descriptor when we override,\n    // so `findPropertyTarget` will return either the original property name (\"property\") or\n    // the \"super\" property name (somehing like \"$jsii$super$<property>$\").\n    const propertyToGet = this._findPropertyTarget(instance, property);\n\n    // make the actual \"get\", and block any async calls that might be performed\n    // by jsii overrides.\n    const value = this._ensureSync(\n      `property '${objref[TOKEN_REF]}.${propertyToGet}'`,\n      () => instance[propertyToGet],\n    );\n    this._debug('value:', value);\n    const ret = this._fromSandbox(value, ti, `of property ${fqn}.${property}`);\n    this._debug('ret:', ret);\n    return { value: ret };\n  }\n\n  public set(req: api.SetRequest): api.SetResponse {\n    const { objref, property, value } = req;\n    this._debug('set', objref, property, value);\n    const { instance, fqn, interfaces } = this.objects.findObject(objref);\n\n    const propInfo = this._typeInfoForProperty(req.property, fqn, interfaces);\n\n    if (propInfo.immutable) {\n      throw new Error(\n        `Cannot set value of immutable property ${req.property} to ${req.value}`,\n      );\n    }\n\n    const propertyToSet = this._findPropertyTarget(instance, property);\n\n    this._ensureSync(\n      `property '${objref[TOKEN_REF]}.${propertyToSet}'`,\n      () =>\n        (instance[propertyToSet] = this._toSandbox(\n          value,\n          propInfo,\n          `assigned to property ${fqn}.${property}`,\n        )),\n    );\n\n    return {};\n  }\n\n  public invoke(req: api.InvokeRequest): api.InvokeResponse {\n    const { objref, method } = req;\n    const args = req.args ?? [];\n\n    this._debug('invoke', objref, method, args);\n    const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);\n\n    // verify this is not an async method\n    if (ti.async) {\n      throw new Error(`${method} is an async method, use \"begin\" instead`);\n    }\n\n    const fqn = jsiiTypeFqn(obj);\n    const ret = this._ensureSync(\n      `method '${objref[TOKEN_REF]}.${method}'`,\n      () => {\n        return fn.apply(\n          obj,\n          this._toSandboxValues(\n            args,\n            `method ${fqn ? `${fqn}#` : ''}${method}`,\n            ti.parameters,\n          ),\n        );\n      },\n    );\n\n    const result = this._fromSandbox(\n      ret,\n      ti.returns ?? 'void',\n      `returned by method ${fqn ? `${fqn}#` : ''}${method}`,\n    );\n    this._debug('invoke result', result);\n\n    return { result };\n  }\n\n  public sinvoke(req: api.StaticInvokeRequest): api.InvokeResponse {\n    const { fqn, method } = req;\n    const args = req.args ?? [];\n\n    this._debug('sinvoke', fqn, method, args);\n\n    const ti = this._typeInfoForMethod(method, fqn);\n\n    if (!ti.static) {\n      throw new Error(`${fqn}.${method} is not a static method`);\n    }\n\n    // verify this is not an async method\n    if (ti.async) {\n      throw new Error(`${method} is an async method, use \"begin\" instead`);\n    }\n\n    const prototype = this._findSymbol(fqn);\n    const fn = prototype[method] as (...params: any[]) => any;\n\n    const ret = this._ensureSync(`method '${fqn}.${method}'`, () => {\n      return fn.apply(\n        prototype,\n        this._toSandboxValues(\n          args,\n          `static method ${fqn}.${method}`,\n          ti.parameters,\n        ),\n      );\n    });\n\n    this._debug('method returned:', ret);\n    return {\n      result: this._fromSandbox(\n        ret,\n        ti.returns ?? 'void',\n        `returned by static method ${fqn}.${method}`,\n      ),\n    };\n  }\n\n  public begin(req: api.BeginRequest): api.BeginResponse {\n    const { objref, method } = req;\n    const args = req.args ?? [];\n\n    this._debug('begin', objref, method, args);\n\n    if (this.syncInProgress) {\n      throw new Error(\n        `Cannot invoke async method '${req.objref[TOKEN_REF]}.${req.method}' while sync ${this.syncInProgress} is being processed`,\n      );\n    }\n\n    const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);\n\n    // verify this is indeed an async method\n    if (!ti.async) {\n      throw new Error(`Method ${method} is expected to be an async method`);\n    }\n\n    const fqn = jsiiTypeFqn(obj);\n\n    const promise = fn.apply(\n      obj,\n      this._toSandboxValues(\n        args,\n        `async method ${fqn ? `${fqn}#` : ''}${method}`,\n        ti.parameters,\n      ),\n    ) as Promise<any>;\n\n    // since we are planning to resolve this promise in a different scope\n    // we need to handle rejections here [1]\n    // [1]: https://stackoverflow.com/questions/40920179/should-i-refrain-from-handling-promise-rejection-asynchronously/40921505\n    promise.catch((_) => undefined);\n\n    const prid = this._makeprid();\n    this.promises.set(prid, {\n      promise,\n      method: ti,\n    });\n\n    return { promiseid: prid };\n  }\n\n  public async end(req: api.EndRequest): Promise<api.EndResponse> {\n    const { promiseid } = req;\n\n    this._debug('end', promiseid);\n\n    const storedPromise = this.promises.get(promiseid);\n    if (storedPromise == null) {\n      throw new Error(`Cannot find promise with ID: ${promiseid}`);\n    }\n    const { promise, method } = storedPromise;\n\n    let result;\n    try {\n      result = await promise;\n      this._debug('promise result:', result);\n    } catch (e) {\n      this._debug('promise error:', e);\n      throw e;\n    }\n\n    return {\n      result: this._fromSandbox(\n        result,\n        method.returns ?? 'void',\n        `returned by async method ${method.name}`,\n      ),\n    };\n  }\n\n  public callbacks(_req?: api.CallbacksRequest): api.CallbacksResponse {\n    this._debug('callbacks');\n    const ret = Array.from(this.cbs.entries()).map(([cbid, cb]) => {\n      this.waiting.set(cbid, cb); // move to waiting\n      this.cbs.delete(cbid); // remove from created\n      const callback: api.Callback = {\n        cbid,\n        cookie: cb.override.cookie,\n        invoke: {\n          objref: cb.objref,\n          method: cb.override.method,\n          args: cb.args,\n        },\n      };\n      return callback;\n    });\n\n    return { callbacks: ret };\n  }\n\n  public complete(req: api.CompleteRequest): api.CompleteResponse {\n    const { cbid, err, result } = req;\n\n    this._debug('complete', cbid, err, result);\n\n    const cb = this.waiting.get(cbid);\n    if (!cb) {\n      throw new Error(`Callback ${cbid} not found`);\n    }\n\n    if (err) {\n      this._debug('completed with error:', err);\n      cb.fail(new Error(err));\n    } else {\n      const sandoxResult = this._toSandbox(\n        result,\n        cb.expectedReturnType ?? 'void',\n        `returned by callback ${cb.toString()}`,\n      );\n      this._debug('completed with result:', sandoxResult);\n      cb.succeed(sandoxResult);\n    }\n\n    this.waiting.delete(cbid);\n\n    return { cbid };\n  }\n\n  /**\n   * Returns the language-specific names for a jsii module.\n   * @param assemblyName The name of the jsii module (i.e. jsii$jsii_calculator_lib$)\n   */\n  public naming(req: api.NamingRequest): api.NamingResponse {\n    const assemblyName = req.assembly;\n\n    this._debug('naming', assemblyName);\n\n    const assembly = this._assemblyFor(assemblyName);\n    const targets = assembly.metadata.targets;\n    if (!targets) {\n      throw new Error(`Unexpected - \"targets\" for ${assemblyName} is missing!`);\n    }\n\n    return { naming: targets };\n  }\n\n  public stats(_req?: api.StatsRequest): api.StatsResponse {\n    return {\n      objectCount: this.objects.count,\n    };\n  }\n\n  private _addAssembly(assm: Assembly) {\n    this.assemblies.set(assm.metadata.name, assm);\n\n    // add the __jsii__.fqn property on every constructor. this allows\n    // traversing between the javascript and jsii worlds given any object.\n    for (const fqn of Object.keys(assm.metadata.types ?? {})) {\n      const typedef = assm.metadata.types![fqn];\n      switch (typedef.kind) {\n        case spec.TypeKind.Interface:\n          continue; // interfaces don't really exist\n        case spec.TypeKind.Class:\n        case spec.TypeKind.Enum:\n          const constructor = this._findSymbol(fqn);\n          tagJsiiConstructor(constructor, fqn, assm.metadata.version);\n      }\n    }\n  }\n\n  // find the javascript constructor function for a jsii FQN.\n  private _findCtor(\n    fqn: string,\n    args: any[],\n  ): { ctor: any; parameters?: spec.Parameter[] } {\n    if (fqn === wire.EMPTY_OBJECT_FQN) {\n      return { ctor: Object };\n    }\n\n    const typeinfo = this._typeInfoForFqn(fqn);\n\n    switch (typeinfo.kind) {\n      case spec.TypeKind.Class:\n        const classType = typeinfo as spec.ClassType;\n        this._validateMethodArguments(classType.initializer, args);\n        return {\n          ctor: this._findSymbol(fqn),\n          parameters: classType.initializer && classType.initializer.parameters,\n        };\n\n      case spec.TypeKind.Interface:\n        throw new Error(\n          `Cannot create an object with an FQN of an interface: ${fqn}`,\n        );\n\n      default:\n        throw new Error(`Unexpected FQN kind: ${fqn}`);\n    }\n  }\n\n  private _getPackageDir(pkgname: string): string {\n    if (!this.installDir) {\n      this.installDir = fs.mkdtempSync(path.join(os.tmpdir(), 'jsii-kernel-'));\n      this.require = createRequire(this.installDir);\n      fs.mkdirpSync(path.join(this.installDir, 'node_modules'));\n      this._debug('creating jsii-kernel modules workdir:', this.installDir);\n\n      onExit.removeSync(this.installDir);\n    }\n    return path.join(this.installDir, 'node_modules', pkgname);\n  }\n\n  // prefixed with _ to allow calling this method internally without\n  // getting it recorded for testing.\n  private _create(req: api.CreateRequest): api.CreateResponse {\n    this._debug('create', req);\n    const { fqn, interfaces, overrides } = req;\n\n    const requestArgs = req.args ?? [];\n\n    const ctorResult = this._findCtor(fqn, requestArgs);\n    const ctor = ctorResult.ctor;\n    const obj = new ctor(\n      ...this._toSandboxValues(\n        requestArgs,\n        `new ${fqn}`,\n        ctorResult.parameters,\n      ),\n    );\n    const objref = this.objects.registerObject(obj, fqn, req.interfaces ?? []);\n\n    // overrides: for each one of the override method names, installs a\n    // method on the newly created object which represents the remote \"reverse proxy\".\n\n    if (overrides) {\n      this._debug('overrides', overrides);\n\n      const overrideTypeErrorMessage =\n        'Override can either be \"method\" or \"property\"';\n      const methods = new Set<string>();\n      const properties = new Set<string>();\n\n      for (const override of overrides) {\n        if (api.isMethodOverride(override)) {\n          if (api.isPropertyOverride(override)) {\n            throw new Error(overrideTypeErrorMessage);\n          }\n          if (methods.has(override.method)) {\n            throw new Error(\n              `Duplicate override for method '${override.method}'`,\n            );\n          }\n          methods.add(override.method);\n\n          this._applyMethodOverride(obj, objref, fqn, interfaces, override);\n        } else if (api.isPropertyOverride(override)) {\n          if (api.isMethodOverride(override)) {\n            throw new Error(overrideTypeErrorMessage);\n          }\n          if (properties.has(override.property)) {\n            throw Error(\n              `Duplicate override for property '${override.property}'`,\n            );\n          }\n          properties.add(override.property);\n\n          this._applyPropertyOverride(obj, objref, fqn, interfaces, override);\n        } else {\n          throw new Error(overrideTypeErrorMessage);\n        }\n      }\n    }\n\n    return objref;\n  }\n\n  private _getSuperPropertyName(name: string) {\n    return `$jsii$super$${name}$`;\n  }\n\n  private _applyPropertyOverride(\n    obj: any,\n    objref: api.ObjRef,\n    typeFqn: string,\n    interfaces: string[] | undefined,\n    override: api.PropertyOverride,\n  ) {\n    // error if we can find a method with this name\n    if (this._tryTypeInfoForMethod(override.property, typeFqn, interfaces)) {\n      throw new Error(\n        `Trying to override method '${override.property}' as a property`,\n      );\n    }\n\n    let propInfo = this._tryTypeInfoForProperty(\n      override.property,\n      typeFqn,\n      interfaces,\n    );\n    // if this is a private property (i.e. doesn't have `propInfo` the object has a key)\n    if (!propInfo && override.property in obj) {\n      this._debug(`Skipping override of private property ${override.property}`);\n      return;\n    }\n\n    if (!propInfo) {\n      // We've overriding a property on an object we have NO type information on (probably\n      // because it's an anonymous object).\n      // Pretend it's 'prop: any';\n      //\n      // FIXME: We could do better type checking during the conversion if JSII clients\n      // would tell us the intended interface type.\n      propInfo = {\n        name: override.property,\n        type: spec.CANONICAL_ANY,\n      };\n    }\n\n    this._defineOverridenProperty(obj, objref, override, propInfo);\n  }\n\n  private _defineOverridenProperty(\n    obj: any,\n    objref: api.ObjRef,\n    override: api.PropertyOverride,\n    propInfo: spec.Property,\n  ) {\n    const propertyName = override.property;\n\n    this._debug('apply override', propertyName);\n\n    // save the old property under $jsii$super$<prop>$ so that property overrides\n    // can still access it via `super.<prop>`.\n    const prev = getPropertyDescriptor(obj, propertyName) ?? {\n      value: obj[propertyName],\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    };\n\n    const prevEnumerable = prev.enumerable;\n    prev.enumerable = false;\n    Object.defineProperty(obj, this._getSuperPropertyName(propertyName), prev);\n\n    // we add callbacks for both 'get' and 'set', even if the property\n    // is readonly. this is fine because if you try to set() a readonly\n    // property, it will fail.\n    Object.defineProperty(obj, propertyName, {\n      enumerable: prevEnumerable,\n      configurable: prev.configurable,\n      get: () => {\n        this._debug('virtual get', objref, propertyName, {\n          cookie: override.cookie,\n        });\n        const result = this.callbackHandler({\n          cookie: override.cookie,\n          cbid: this._makecbid(),\n          get: { objref, property: propertyName },\n        });\n        this._debug('callback returned', result);\n        return this._toSandbox(\n          result,\n          propInfo,\n          `returned by callback property ${propertyName}`,\n        );\n      },\n      set: (value: any) => {\n        this._debug('virtual set', objref, propertyName, {\n          cookie: override.cookie,\n        });\n        this.callbackHandler({\n          cookie: override.cookie,\n          cbid: this._makecbid(),\n          set: {\n            objref,\n            property: propertyName,\n            value: this._fromSandbox(\n              value,\n              propInfo,\n              `assigned to callback property ${propertyName}`,\n            ),\n          },\n        });\n      },\n    });\n\n    function getPropertyDescriptor(\n      obj: any,\n      propertyName: string,\n    ): PropertyDescriptor | undefined {\n      const direct = Object.getOwnPropertyDescriptor(obj, propertyName);\n      if (direct != null) {\n        return direct;\n      }\n      const proto = Object.getPrototypeOf(obj);\n      if (proto == null && proto !== Object.prototype) {\n        // We reached Object or the prototype chain root, all hope is lost!\n        return undefined;\n      }\n      return getPropertyDescriptor(proto, propertyName);\n    }\n  }\n\n  private _applyMethodOverride(\n    obj: any,\n    objref: api.ObjRef,\n    typeFqn: string,\n    interfaces: string[] | undefined,\n    override: api.MethodOverride,\n  ) {\n    // error if we can find a property with this name\n    if (this._tryTypeInfoForProperty(override.method, typeFqn, interfaces)) {\n      throw new Error(\n        `Trying to override property '${override.method}' as a method`,\n      );\n    }\n\n    let methodInfo = this._tryTypeInfoForMethod(\n      override.method,\n      typeFqn,\n      interfaces,\n    );\n\n    // If this is a private method (doesn't have methodInfo, key resolves on the object), we\n    // are going to skip the override.\n    if (!methodInfo && obj[override.method]) {\n      this._debug(`Skipping override of private method ${override.method}`);\n      return;\n    }\n\n    if (!methodInfo) {\n      // We've overriding a method on an object we have NO type information on (probably\n      // because it's an anonymous object).\n      // Pretend it's an (...args: any[]) => any\n      methodInfo = {\n        name: override.method,\n        returns: { type: spec.CANONICAL_ANY },\n        parameters: [\n          {\n            name: 'args',\n            type: spec.CANONICAL_ANY,\n            variadic: true,\n          },\n        ],\n        variadic: true,\n      };\n    }\n\n    this._defineOverridenMethod(obj, objref, override, methodInfo);\n  }\n\n  private _defineOverridenMethod(\n    obj: any,\n    objref: api.ObjRef,\n    override: api.MethodOverride,\n    methodInfo: spec.Method,\n  ) {\n    const methodName = override.method;\n    const fqn = jsiiTypeFqn(obj);\n    const methodContext = `${methodInfo.async ? 'async ' : ''}method${\n      fqn ? `${fqn}#` : methodName\n    }`;\n\n    if (methodInfo.async) {\n      // async method override\n      Object.defineProperty(obj, methodName, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: (...methodArgs: any[]) => {\n          this._debug('invoke async method override', override);\n          const args = this._toSandboxValues(\n            methodArgs,\n            methodContext,\n            methodInfo.parameters,\n          );\n          return new Promise<any>((succeed, fail) => {\n            const cbid = this._makecbid();\n            this._debug('adding callback to queue', cbid);\n            this.cbs.set(cbid, {\n              objref,\n              override,\n              args,\n              expectedReturnType: methodInfo.returns ?? 'void',\n              succeed,\n              fail,\n            });\n          });\n        },\n      });\n    } else {\n      // sync method override (method info is not required)\n      Object.defineProperty(obj, methodName, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: (...methodArgs: any[]) => {\n          this._debug(\n            'invoke sync method override',\n            override,\n            'args',\n            methodArgs,\n          );\n          // We should be validating the actual arguments according to the\n          // declared parameters here, but let's just assume the JSII runtime on the\n          // other end has done its work.\n          const result = this.callbackHandler({\n            cookie: override.cookie,\n            cbid: this._makecbid(),\n            invoke: {\n              objref,\n              method: methodName,\n              args: this._fromSandboxValues(\n                methodArgs,\n                methodContext,\n                methodInfo.parameters,\n              ),\n            },\n          });\n          this._debug('Result', result);\n          return this._toSandbox(\n            result,\n            methodInfo.returns ?? 'void',\n            `returned by callback method ${methodName}`,\n          );\n        },\n      });\n    }\n  }\n\n  private _findInvokeTarget(\n    objref: api.ObjRef,\n    methodName: string,\n    args: any[],\n  ) {\n    const { instance, fqn, interfaces } = this.objects.findObject(objref);\n    const ti = this._typeInfoForMethod(methodName, fqn, interfaces);\n    this._validateMethodArguments(ti, args);\n\n    // always first look up the method in the prototype. this practically bypasses\n    // any methods overridden by derived classes (which are by definition native\n    // methods). this serves to allow native call to invoke \"super.method()\" when\n    // overriding the method.\n    // if we didn't find the method on the prototype, it could be a literal object\n    // that implements an interface, so we look if we have the method on the object\n    // itself. if we do, we invoke it.\n    let fn = instance.constructor.prototype[methodName];\n    if (!fn) {\n      fn = instance[methodName];\n      if (!fn) {\n        throw new Error(`Cannot find ${methodName} on object`);\n      }\n    }\n    return { ti, obj: instance, fn };\n  }\n\n  private _validateMethodArguments(\n    method: spec.Callable | undefined,\n    args: any[],\n  ) {\n    const params: spec.Parameter[] = method?.parameters ?? [];\n\n    // error if args > params\n    if (args.length > params.length && !(method && method.variadic)) {\n      throw new Error(\n        `Too many arguments (method accepts ${params.length} parameters, got ${args.length} arguments)`,\n      );\n    }\n\n    for (let i = 0; i < params.length; ++i) {\n      const param = params[i];\n      const arg = args[i];\n\n      if (param.variadic) {\n        if (params.length <= i) {\n          return;\n        } // No vararg was provided\n        for (let j = i; j < params.length; j++) {\n          if (!param.optional && params[j] === undefined) {\n            throw new Error(\n              `Unexpected 'undefined' value at index ${\n                j - i\n              } of variadic argument '${\n                param.name\n              }' of type '${spec.describeTypeReference(param.type)}'`,\n            );\n          }\n        }\n      } else if (!param.optional && arg === undefined) {\n        throw new Error(\n          `Not enough arguments. Missing argument for the required parameter '${\n            param.name\n          }' of type '${spec.describeTypeReference(param.type)}'`,\n        );\n      }\n    }\n  }\n\n  private _assemblyFor(assemblyName: string) {\n    const assembly = this.assemblies.get(assemblyName);\n    if (!assembly) {\n      throw new Error(`Could not find assembly: ${assemblyName}`);\n    }\n    return assembly;\n  }\n\n  private _findSymbol(fqn: string) {\n    const [assemblyName, ...parts] = fqn.split('.');\n    const assembly = this._assemblyFor(assemblyName);\n\n    let curr = assembly.closure;\n    while (parts.length > 0) {\n      const name = parts.shift();\n      if (!name) {\n        break;\n      }\n\n      curr = curr[name];\n    }\n    if (!curr) {\n      throw new Error(`Could not find symbol ${fqn}`);\n    }\n    return curr;\n  }\n\n  private _typeInfoForFqn(fqn: string): spec.Type {\n    const components = fqn.split('.');\n    const moduleName = components[0];\n\n    const assembly = this.assemblies.get(moduleName);\n    if (!assembly) {\n      throw new Error(`Module '${moduleName}' not found`);\n    }\n\n    const types = assembly.metadata.types ?? {};\n    const fqnInfo = types[fqn];\n    if (!fqnInfo) {\n      throw new Error(`Type '${fqn}' not found`);\n    }\n\n    return fqnInfo;\n  }\n\n  private _typeInfoForMethod(\n    methodName: string,\n    fqn: string,\n    interfaces?: string[],\n  ): spec.Method {\n    const ti = this._tryTypeInfoForMethod(methodName, fqn, interfaces);\n    if (!ti) {\n      const addendum =\n        interfaces && interfaces.length > 0\n          ? ` or interface(s) ${interfaces.join(', ')}`\n          : '';\n      throw new Error(\n        `Class ${fqn}${addendum} doesn't have a method '${methodName}'`,\n      );\n    }\n    return ti;\n  }\n\n  private _tryTypeInfoForMethod(\n    methodName: string,\n    classFqn: string,\n    interfaces: string[] = [],\n  ): spec.Method | undefined {\n    for (const fqn of [classFqn, ...interfaces]) {\n      if (fqn === wire.EMPTY_OBJECT_FQN) {\n        continue;\n      }\n      const typeinfo = this._typeInfoForFqn(fqn);\n\n      const methods =\n        (typeinfo as spec.ClassType | spec.InterfaceType).methods ?? [];\n\n      for (const m of methods) {\n        if (m.name === methodName) {\n          return m;\n        }\n      }\n\n      // recursion to parent type (if exists)\n      const bases = [\n        (typeinfo as spec.ClassType).base,\n        ...((typeinfo as spec.InterfaceType).interfaces ?? []),\n      ];\n      for (const base of bases) {\n        if (!base) {\n          continue;\n        }\n\n        const found = this._tryTypeInfoForMethod(methodName, base);\n        if (found) {\n          return found;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private _tryTypeInfoForProperty(\n    property: string,\n    classFqn: string,\n    interfaces: string[] = [],\n  ): spec.Property | undefined {\n    for (const fqn of [classFqn, ...interfaces]) {\n      if (fqn === wire.EMPTY_OBJECT_FQN) {\n        continue;\n      }\n      const typeInfo = this._typeInfoForFqn(fqn);\n\n      let properties;\n      let bases;\n\n      if (spec.isClassType(typeInfo)) {\n        const classTypeInfo = typeInfo as spec.ClassType;\n        properties = classTypeInfo.properties;\n        bases = classTypeInfo.base ? [classTypeInfo.base] : [];\n      } else if (spec.isInterfaceType(typeInfo)) {\n        const interfaceTypeInfo = typeInfo as spec.InterfaceType;\n        properties = interfaceTypeInfo.properties;\n        bases = interfaceTypeInfo.interfaces ?? [];\n      } else {\n        throw new Error(\n          `Type of kind ${typeInfo.kind} does not have properties`,\n        );\n      }\n\n      for (const p of properties ?? []) {\n        if (p.name === property) {\n          return p;\n        }\n      }\n\n      // recurse to parent type (if exists)\n      for (const baseFqn of bases) {\n        const ret = this._tryTypeInfoForProperty(property, baseFqn);\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private _typeInfoForProperty(\n    property: string,\n    fqn: string,\n    interfaces?: string[],\n  ): spec.Property {\n    const typeInfo = this._tryTypeInfoForProperty(property, fqn, interfaces);\n    if (!typeInfo) {\n      const addendum =\n        interfaces && interfaces.length > 0\n          ? ` or interface(s) ${interfaces.join(', ')}`\n          : '';\n      throw new Error(\n        `Type ${fqn}${addendum} doesn't have a property '${property}'`,\n      );\n    }\n    return typeInfo;\n  }\n  private _toSandbox(\n    v: any,\n    expectedType: wire.OptionalValueOrVoid,\n    context: string,\n  ): any {\n    return wire.process(\n      {\n        objects: this.objects,\n        debug: this._debug.bind(this),\n        findSymbol: this._findSymbol.bind(this),\n        lookupType: this._typeInfoForFqn.bind(this),\n      },\n      'deserialize',\n      v,\n      expectedType,\n      context,\n    );\n  }\n\n  private _fromSandbox(\n    v: any,\n    targetType: wire.OptionalValueOrVoid,\n    context: string,\n  ): any {\n    return wire.process(\n      {\n        objects: this.objects,\n        debug: this._debug.bind(this),\n        findSymbol: this._findSymbol.bind(this),\n        lookupType: this._typeInfoForFqn.bind(this),\n      },\n      'serialize',\n      v,\n      targetType,\n      context,\n    );\n  }\n\n  private _toSandboxValues(\n    xs: readonly unknown[],\n    methodContext: string,\n    parameters: readonly spec.Parameter[] | undefined,\n  ) {\n    return this._boxUnboxParameters(\n      xs,\n      methodContext,\n      parameters,\n      this._toSandbox.bind(this),\n    );\n  }\n\n  private _fromSandboxValues(\n    xs: readonly unknown[],\n    methodContext: string,\n    parameters: readonly spec.Parameter[] | undefined,\n  ) {\n    return this._boxUnboxParameters(\n      xs,\n      methodContext,\n      parameters,\n      this._fromSandbox.bind(this),\n    );\n  }\n\n  private _boxUnboxParameters(\n    xs: readonly unknown[],\n    methodContext: string,\n    parameters: readonly spec.Parameter[] = [],\n    boxUnbox: (x: any, t: wire.OptionalValueOrVoid, context: string) => any,\n  ) {\n    const parametersCopy = [...parameters];\n    const variadic =\n      parametersCopy.length > 0 &&\n      !!parametersCopy[parametersCopy.length - 1].variadic;\n    // Repeat the last (variadic) type to match the number of actual arguments\n    while (variadic && parametersCopy.length < xs.length) {\n      parametersCopy.push(parametersCopy[parametersCopy.length - 1]);\n    }\n    if (xs.length > parametersCopy.length) {\n      throw new Error(\n        `Argument list (${JSON.stringify(\n          xs,\n        )}) not same size as expected argument list (length ${\n          parametersCopy.length\n        })`,\n      );\n    }\n    return xs.map((x, i) =>\n      boxUnbox(\n        x,\n        parametersCopy[i],\n        `passed to parameter ${parametersCopy[i].name} of ${methodContext}`,\n      ),\n    );\n  }\n\n  private _debug(...args: any[]) {\n    if (this.traceEnabled) {\n      console.error('[@jsii/kernel]', ...args);\n    }\n  }\n\n  private _debugTime<T>(cb: () => T, label: string): T {\n    const fullLabel = `[@jsii/kernel:timing] ${label}`;\n    if (this.debugTimingEnabled) {\n      console.time(fullLabel);\n    }\n    try {\n      return cb();\n    } finally {\n      if (this.debugTimingEnabled) {\n        console.timeEnd(fullLabel);\n      }\n    }\n  }\n\n  /**\n   * Ensures that `fn` is called and defends against beginning to invoke\n   * async methods until fn finishes (successfully or not).\n   */\n  private _ensureSync<T>(desc: string, fn: () => T): T {\n    this.syncInProgress = desc;\n    try {\n      return fn();\n    } finally {\n      delete this.syncInProgress;\n    }\n  }\n\n  private _findPropertyTarget(obj: any, property: string) {\n    const superProp = this._getSuperPropertyName(property);\n    if (superProp in obj) {\n      return superProp;\n    }\n    return property;\n  }\n\n  //\n  // type information\n  //\n\n  private _makecbid() {\n    return `jsii::callback::${this.nextid++}`;\n  }\n\n  private _makeprid() {\n    return `jsii::promise::${this.nextid++}`;\n  }\n}\n\ninterface Callback {\n  objref: api.ObjRef;\n  override: api.MethodOverride;\n  args: any[];\n  expectedReturnType: wire.OptionalValueOrVoid;\n\n  // completion callbacks\n  succeed: (...args: any[]) => any;\n  fail: (...args: any[]) => any;\n}\n\ninterface AsyncInvocation {\n  method: spec.Method;\n  promise: Promise<any>;\n}\n\nclass Assembly {\n  public constructor(\n    public readonly metadata: spec.Assembly,\n    public readonly closure: any,\n  ) {}\n}\n","import { copyFileSync, linkSync, mkdirSync, readdirSync, statSync } from 'fs';\nimport { join } from 'path';\n\n/**\n * Creates directories containing hard links if possible, and falls back on\n * copy otherwise.\n *\n * @param existing    is the original file or directory to link.\n * @param destination is the nbew file or directory to create.\n */\nexport function link(existing: string, destination: string): void {\n  const stat = statSync(existing);\n  if (!stat.isDirectory()) {\n    try {\n      linkSync(existing, destination);\n    } catch {\n      copyFileSync(existing, destination);\n    }\n    return;\n  }\n\n  mkdirSync(destination, { recursive: true });\n  for (const file of readdirSync(existing)) {\n    link(join(existing, file), join(destination, file));\n  }\n}\n","import * as spec from '@jsii/spec';\n\nimport * as api from './api';\nimport { EMPTY_OBJECT_FQN } from './serialization';\n\n/**\n * Symbol under which we store the { type -> objid } map on object instances\n */\nconst OBJID_SYMBOL = Symbol.for('$__jsii__objid__$');\n\n/**\n * Symbol under which we store the interfaces implemented by instances\n */\nconst IFACES_SYMBOL = Symbol.for('$__jsii__interfaces__$');\n\n/**\n * Symbol we use to tag the constructor of a JSII class\n */\nconst JSII_RTTI_SYMBOL = Symbol.for('jsii.rtti');\n\ninterface ManagedConstructor {\n  readonly [JSII_RTTI_SYMBOL]: {\n    readonly fqn: string;\n    readonly version: string;\n  };\n}\n\ntype MaybeManagedConstructor = Partial<ManagedConstructor>;\n\n/**\n * Get the JSII fqn for an object (if available)\n *\n * This will return something if the object was constructed from a JSII-enabled\n * class/constructor, or if a literal object was annotated with type\n * information.\n */\nexport function jsiiTypeFqn(obj: any): string | undefined {\n  return (obj.constructor as MaybeManagedConstructor)[JSII_RTTI_SYMBOL]?.fqn;\n}\n\n/**\n * If this object was previously serialized under a given reference, return the same reference\n *\n * This is to retain object identity across invocations.\n */\nexport function objectReference(obj: unknown): api.ObjRef | undefined {\n  // If this object as already returned\n  if ((obj as any)[OBJID_SYMBOL]) {\n    return {\n      [api.TOKEN_REF]: (obj as ManagedObject)[OBJID_SYMBOL],\n      [api.TOKEN_INTERFACES]: (obj as ManagedObject)[IFACES_SYMBOL],\n    };\n  }\n\n  return undefined;\n}\n\ntype ManagedObject = {\n  [OBJID_SYMBOL]: string;\n  [IFACES_SYMBOL]?: string[];\n};\n\nfunction tagObject(obj: unknown, objid: string, interfaces?: string[]) {\n  const privateField: Omit<PropertyDescriptor, 'value' | 'get' | 'set'> = {\n    // Make sure the field does not show in `JSON.stringify` outputs, and is not\n    // copied by splat expressions (`{...obj}`), as this would be problematic.\n    // See https://github.com/aws/aws-cdk/issues/17876 for an example of the\n    // consequences this could have.\n    enumerable: false,\n    // Probably not necessary, but allow the property to be re-configured (it\n    // would be good to make this `false` in the future, but might cause weird\n    // bugs, so not doing it now...)\n    configurable: true,\n    writable: true,\n  };\n\n  // Log a warning in case we are re-tagging this value, so we can hopefully\n  // discover about the bugs we'd have if we did not make it configurable nor\n  // writable.\n  if (Object.prototype.hasOwnProperty.call(obj, OBJID_SYMBOL)) {\n    console.error(\n      `[jsii/kernel] WARNING: object ${JSON.stringify(\n        obj as any,\n      )} was already tagged as ${(obj as any)[OBJID_SYMBOL]}!`,\n    );\n  }\n\n  Object.defineProperty(obj, OBJID_SYMBOL, { ...privateField, value: objid });\n  Object.defineProperty(obj, IFACES_SYMBOL, {\n    ...privateField,\n    value: interfaces,\n  });\n}\n\n/**\n * Set the JSII FQN for classes produced by a given constructor\n */\nexport function tagJsiiConstructor(\n  constructor: any,\n  fqn: string,\n  version: string,\n) {\n  if (Object.prototype.hasOwnProperty.call(constructor, JSII_RTTI_SYMBOL)) {\n    return;\n  }\n  Object.defineProperty(constructor, JSII_RTTI_SYMBOL, {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: { fqn, version },\n  });\n}\n\n/**\n * Table of JSII objects\n *\n * There can be multiple references to the same object, each under a different requested\n * type.\n */\nexport class ObjectTable {\n  private readonly objects = new Map<string, RegisteredObject>();\n  private nextid = 10000;\n\n  public constructor(\n    private readonly resolveType: (fqn: string) => spec.Type,\n  ) {}\n\n  /**\n   * Register the given object with the given type\n   *\n   * Return the existing registration if available.\n   */\n  public registerObject(\n    obj: unknown,\n    fqn: string,\n    interfaces?: string[],\n  ): api.ObjRef {\n    if (fqn === undefined) {\n      throw new Error('FQN cannot be undefined');\n    }\n\n    const existingRef = objectReference(obj);\n    if (existingRef) {\n      if (interfaces) {\n        const allIfaces = new Set(interfaces);\n        for (const iface of existingRef[api.TOKEN_INTERFACES] ?? []) {\n          allIfaces.add(iface);\n        }\n        // Note - obj[INTERFACES_SYMBOL] should already have been declared as a\n        // private property by a previous call to tagObject  at this stage.\n        if (!Object.prototype.hasOwnProperty.call(obj, IFACES_SYMBOL)) {\n          console.error(\n            `[jsii/kernel] WARNING: referenced object ${\n              existingRef[api.TOKEN_REF]\n            } does not have the ${String(IFACES_SYMBOL)} property!`,\n          );\n        }\n\n        this.objects.get(existingRef[api.TOKEN_REF])!.interfaces =\n          (obj as any)[IFACES_SYMBOL] =\n          existingRef[api.TOKEN_INTERFACES] =\n          interfaces =\n            this.removeRedundant(Array.from(allIfaces), fqn);\n      }\n      return existingRef;\n    }\n\n    interfaces = this.removeRedundant(interfaces, fqn);\n\n    const objid = this.makeId(fqn);\n    this.objects.set(objid, { instance: obj, fqn, interfaces });\n    tagObject(obj, objid, interfaces);\n\n    return { [api.TOKEN_REF]: objid, [api.TOKEN_INTERFACES]: interfaces };\n  }\n\n  /**\n   * Find the object and registered type for the given ObjRef\n   */\n  public findObject(objref: api.ObjRef): RegisteredObject {\n    if (typeof objref !== 'object' || !(api.TOKEN_REF in objref)) {\n      throw new Error(`Malformed object reference: ${JSON.stringify(objref)}`);\n    }\n\n    const objid = objref[api.TOKEN_REF];\n    const obj = this.objects.get(objid);\n    if (!obj) {\n      throw new Error(`Object ${objid} not found`);\n    }\n\n    // If there are \"additional\" interfaces declared on the objref, merge them\n    // into the returned object. This is used to support client-side forced\n    // down-casting (a.k.a: unsafe casting). We do NOT register the extra\n    // interfaces here so that if the client provided an interface that is\n    // actually not implemented, we aren't \"poisoning\" our state with that\n    // incorrect information.\n    const additionalInterfaces = objref[api.TOKEN_INTERFACES];\n    if (additionalInterfaces != null && additionalInterfaces.length > 0) {\n      return {\n        ...obj,\n        interfaces: [\n          ...(obj.interfaces ?? []),\n          // We append at the end so \"registered\" interface information has\n          // precedence over client-declared ones.\n          ...additionalInterfaces,\n        ],\n      };\n    }\n\n    return obj;\n  }\n\n  /**\n   * Delete the registration with the given objref\n   */\n  public deleteObject({ [api.TOKEN_REF]: objid }: api.ObjRef) {\n    if (!this.objects.delete(objid)) {\n      throw new Error(`Object ${objid} not found`);\n    }\n  }\n\n  public get count(): number {\n    return this.objects.size;\n  }\n\n  private makeId(fqn: string) {\n    return `${fqn}@${this.nextid++}`;\n  }\n\n  private removeRedundant(\n    interfaces: string[] | undefined,\n    fqn: string,\n  ): string[] | undefined {\n    if (!interfaces || interfaces.length === 0) {\n      return undefined;\n    }\n\n    const result = new Set(interfaces);\n    const builtIn = new InterfaceCollection(this.resolveType);\n\n    if (fqn !== EMPTY_OBJECT_FQN) {\n      builtIn.addFromClass(fqn);\n    }\n    interfaces.forEach(builtIn.addFromInterface.bind(builtIn));\n\n    for (const iface of builtIn) {\n      result.delete(iface);\n    }\n\n    return result.size > 0 ? Array.from(result).sort() : undefined;\n  }\n}\n\nexport interface RegisteredObject {\n  instance: any;\n  fqn: string;\n  interfaces?: string[];\n}\n\nclass InterfaceCollection implements Iterable<string> {\n  private readonly interfaces = new Set<string>();\n\n  public constructor(\n    private readonly resolveType: (fqn: string) => spec.Type,\n  ) {}\n\n  public addFromClass(fqn: string): void {\n    const ti = this.resolveType(fqn);\n    if (!spec.isClassType(ti)) {\n      throw new Error(\n        `Expected a class, but received ${spec.describeTypeReference(ti)}`,\n      );\n    }\n    if (ti.base) {\n      this.addFromClass(ti.base);\n    }\n    if (ti.interfaces) {\n      for (const iface of ti.interfaces) {\n        if (this.interfaces.has(iface)) {\n          continue;\n        }\n        this.interfaces.add(iface);\n        this.addFromInterface(iface);\n      }\n    }\n  }\n\n  public addFromInterface(fqn: string): void {\n    const ti = this.resolveType(fqn);\n    if (!spec.isInterfaceType(ti)) {\n      throw new Error(\n        `Expected an interface, but received ${spec.describeTypeReference(ti)}`,\n      );\n    }\n    if (!ti.interfaces) {\n      return;\n    }\n    for (const iface of ti.interfaces) {\n      if (this.interfaces.has(iface)) {\n        continue;\n      }\n      this.interfaces.add(iface);\n      this.addFromInterface(iface);\n    }\n  }\n\n  public [Symbol.iterator]() {\n    return this.interfaces[Symbol.iterator]();\n  }\n}\n","import * as fs from 'fs-extra';\nimport * as process from 'process';\n\nconst removeSyncPaths = new Array<string>();\n\nexport function removeSync(path: string): void {\n  registerIfNeeded();\n  removeSyncPaths.push(path);\n}\n\nlet registered = false;\n\n/**\n * Registers the exist handler if it has not been registered already. This is done exactly ocne per\n * process, so that processes with multiple kernels don't end up creating too many exit handlers, as\n * this reduces the chances they will correctly run.\n */\nfunction registerIfNeeded() {\n  if (registered) {\n    return;\n  }\n  process.once('exit', onExitHandler);\n  registered = true;\n\n  function onExitHandler() {\n    if (removeSyncPaths.length > 0) {\n      for (const path of removeSyncPaths) {\n        fs.removeSync(path);\n      }\n    }\n  }\n}\n","/**\n * Handling of types in JSII\n *\n * Types will be serialized according to the following table:\n *\n *                         \n *                          JAVASCRIPT TYPE                                                                               \n *                         \n *                          undefined/null    date     scalar (*)      array      JSII-class object  literal object  \n * \n *  DECLARED  void        undefined       undefined  undefined   undefined      undefined          undefined       \n *  TYPE      date        undefined()    { date }   -           -              -                  -               \n *            scalar (*)  undefined()    -          value       -              -                  -               \n *            json        undefined       string     value       array/R(json)  -                  byvalue/R(json) \n *            enum        undefined()    -          { enum }    -              -                  -               \n *            array of T  undefined()    -          -           array/R(T)     -                  -               \n *            map of T    undefined()    -          -           -              -                  byvalue/R(T)    \n *            interface   undefined()    -          -           -              { ref }            { ref: proxy }  \n *            struct      undefined()    -          -           -              -                  byvalue/R(T[k]) \n *            class       undefined()    -          -           -              { ref }            { ref: proxy }  \n *            any         undefined       { date }   value       array/R(any)   { ref }            byvalue/R(any)  \n * \n *\n *  - (*) scalar means 'string | number | boolean'\n *  - () throw if not nullable\n *  - /R(t) recurse with declared type t\n */\n\nimport * as spec from '@jsii/spec';\nimport * as assert from 'assert';\nimport { inspect } from 'util';\n\nimport {\n  isObjRef,\n  isWireDate,\n  isWireEnum,\n  isWireMap,\n  isWireStruct,\n  ObjRef,\n  TOKEN_DATE,\n  TOKEN_ENUM,\n  TOKEN_MAP,\n  TOKEN_REF,\n  TOKEN_STRUCT,\n  WireDate,\n  WireEnum,\n} from './api';\nimport { jsiiTypeFqn, objectReference, ObjectTable } from './objects';\n\nimport { api } from '.';\n\n/**\n * A specific singleton type to be explicit about a Void type\n *\n * In the spec, 'void' is represented as 'undefined'(*), but allowing the\n * value 'undefined' in function calls has lead to consumers failing to pass\n * type information that they had, just because they didn't \"have to\" (the\n * parameter was optional).\n *\n * (*) As in, declaration of a method looks like { returns?: TypeReference }\n * and the absence of a type means it returns 'void'.\n */\nexport type Void = 'void';\nconst VOID: Void = 'void';\n\n/**\n * A type instance, or Void\n */\nexport type OptionalValueOrVoid = spec.OptionalValue | Void;\n\n/**\n * A special FQN that can be used to create empty javascript objects.\n */\nexport const EMPTY_OBJECT_FQN = 'Object';\n\nexport const SYMBOL_WIRE_TYPE = Symbol.for('$jsii$wireType$');\n\n/**\n * The type kind, that controls how it will be serialized according to the above table\n */\nexport const enum SerializationClass {\n  Void = 'Void',\n  Date = 'Date',\n  Scalar = 'Scalar',\n  Json = 'Json',\n  Enum = 'Enum',\n  Array = 'Array',\n  Map = 'Map',\n  Struct = 'Struct',\n  ReferenceType = 'RefType',\n  Any = 'Any',\n}\n\ntype TypeLookup = (fqn: spec.FQN) => spec.Type;\ntype SymbolLookup = (fqn: spec.FQN) => any;\n\nexport interface SerializerHost {\n  readonly objects: ObjectTable;\n  debug(...args: any[]): void;\n  lookupType(fqn: string): spec.Type;\n  findSymbol(fqn: spec.FQN): any;\n}\n\ninterface Serializer {\n  serialize(\n    value: unknown,\n    type: OptionalValueOrVoid,\n    host: SerializerHost,\n  ): any;\n  deserialize(\n    value: unknown,\n    type: OptionalValueOrVoid,\n    host: SerializerHost,\n  ): any;\n}\n\nexport const SERIALIZERS: { [k: string]: Serializer } = {\n  // ----------------------------------------------------------------------\n  [SerializationClass.Void]: {\n    serialize(value, _type, host) {\n      if (value != null) {\n        host.debug('Expected void, got', value);\n      }\n      return undefined;\n    },\n\n    deserialize(value, _type, host) {\n      if (value != null) {\n        host.debug('Expected void, got', value);\n      }\n      return undefined;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Date]: {\n    serialize(value, optionalValue): WireDate | undefined {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (!isDate(value)) {\n        throw new SerializationError(`Value is not an instance of Date`, value);\n      }\n      return serializeDate(value);\n    },\n\n    deserialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      if (!isWireDate(value)) {\n        throw new SerializationError(\n          `Value does not have the \"${TOKEN_DATE}\" key`,\n          value,\n        );\n      }\n      return deserializeDate(value);\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Scalar]: {\n    serialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      const primitiveType = optionalValue.type as spec.PrimitiveTypeReference;\n\n      if (!isScalar(value)) {\n        throw new SerializationError(\n          `Value is not a ${spec.describeTypeReference(optionalValue.type)}`,\n          value,\n        );\n      }\n      if (typeof value !== primitiveType.primitive) {\n        throw new SerializationError(\n          `Value is not a ${spec.describeTypeReference(optionalValue.type)}`,\n          value,\n        );\n      }\n      return value;\n    },\n\n    deserialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      const primitiveType = optionalValue.type as spec.PrimitiveTypeReference;\n\n      if (!isScalar(value)) {\n        throw new SerializationError(\n          `Value is not a ${spec.describeTypeReference(optionalValue.type)}`,\n          value,\n        );\n      }\n      if (typeof value !== primitiveType.primitive) {\n        throw new SerializationError(\n          `Value is not a ${spec.describeTypeReference(optionalValue.type)}`,\n          value,\n        );\n      }\n\n      return value;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Json]: {\n    serialize(value, optionalValue) {\n      // /!\\ Top-level \"null\" will turn to undefined, but any null nested in the value is valid JSON, so it'll stay!\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      // Just whatever. Dates will automatically serialize themselves to strings.\n      return value;\n    },\n    deserialize(value, optionalValue, host) {\n      // /!\\ Top-level \"null\" will turn to undefined, but any null nested in the value is valid JSON, so it'll stay!\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      // A mapping object can arrive though here. This would be the case if anything that is valid into a Map<string, ?>\n      // is passed into a JSON transfer point. Indeed, those are also valid JSON! For example, Python \"dicts\" will be\n      // serialized (by the Python runtime) as a $jsii.map (the mapping object). We need to de-serialize that as a\n      // Map<string, JSON> in order to obtain the correct output behavior here!\n      if (isWireMap(value)) {\n        return SERIALIZERS[SerializationClass.Map].deserialize(\n          value,\n          {\n            optional: false,\n            type: {\n              collection: {\n                kind: spec.CollectionKind.Map,\n                elementtype: { primitive: spec.PrimitiveType.Json },\n              },\n            },\n          },\n          host,\n        );\n      }\n\n      if (typeof value !== 'object') {\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        return value.map(mapJsonValue);\n      }\n\n      return mapValues(value, mapJsonValue);\n\n      function mapJsonValue(toMap: any, key: string | number) {\n        if (toMap == null) {\n          return toMap;\n        }\n        return process(\n          host,\n          'deserialize',\n          toMap,\n          {\n            type: { primitive: spec.PrimitiveType.Json },\n          },\n          typeof key === 'string' ? `key ${inspect(key)}` : `index ${key}`,\n        );\n      }\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Enum]: {\n    serialize(value, optionalValue, host): WireEnum | undefined {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (typeof value !== 'string' && typeof value !== 'number') {\n        throw new SerializationError(`Value is not a string or number`, value);\n      }\n\n      host.debug('Serializing enum');\n\n      const enumType = optionalValue.type as spec.NamedTypeReference;\n      const enumMap = host.findSymbol(enumType.fqn);\n      const enumEntry = Object.entries(enumMap).find(([, v]) => v === value);\n      if (!enumEntry) {\n        throw new SerializationError(\n          `Value is not present in enum ${spec.describeTypeReference(\n            enumType,\n          )}`,\n          value,\n        );\n      }\n      return { [TOKEN_ENUM]: `${enumType.fqn}/${enumEntry[0]}` };\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      if (!isWireEnum(value)) {\n        throw new SerializationError(\n          `Value does not have the \"${TOKEN_ENUM}\" key`,\n          value,\n        );\n      }\n\n      return deserializeEnum(value, host.findSymbol);\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Array]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (!Array.isArray(value)) {\n        throw new SerializationError(`Value is not an array`, value);\n      }\n\n      const arrayType = optionalValue.type as spec.CollectionTypeReference;\n\n      return value.map((x, idx) =>\n        process(\n          host,\n          'serialize',\n          x,\n          { type: arrayType.collection.elementtype },\n          `index ${inspect(idx)}`,\n        ),\n      );\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (!Array.isArray(value)) {\n        throw new SerializationError(`Value is not an array`, value);\n      }\n\n      const arrayType = optionalValue.type as spec.CollectionTypeReference;\n\n      return value.map((x, idx) =>\n        process(\n          host,\n          'deserialize',\n          x,\n          { type: arrayType.collection.elementtype },\n          `index ${inspect(idx)}`,\n        ),\n      );\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Map]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      const mapType = optionalValue.type as spec.CollectionTypeReference;\n      return {\n        [TOKEN_MAP]: mapValues(value, (v, key) =>\n          process(\n            host,\n            'serialize',\n            v,\n            { type: mapType.collection.elementtype },\n            `key ${inspect(key)}`,\n          ),\n        ),\n      };\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      const mapType = optionalValue.type as spec.CollectionTypeReference;\n      if (!isWireMap(value)) {\n        // Compatibility mode with older versions that didn't wrap in [TOKEN_MAP]\n        return mapValues(value, (v, key) =>\n          process(\n            host,\n            'deserialize',\n            v,\n            { type: mapType.collection.elementtype },\n            `key ${inspect(key)}`,\n          ),\n        );\n      }\n      const result = mapValues(value[TOKEN_MAP], (v, key) =>\n        process(\n          host,\n          'deserialize',\n          v,\n          { type: mapType.collection.elementtype },\n          `key ${inspect(key)}`,\n        ),\n      );\n      Object.defineProperty(result, SYMBOL_WIRE_TYPE, {\n        configurable: false,\n        enumerable: false,\n        value: TOKEN_MAP,\n        writable: false,\n      });\n      return result;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Struct]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (typeof value !== 'object' || value == null || value instanceof Date) {\n        throw new SerializationError(`Value is not an object`, value);\n      }\n\n      if (Array.isArray(value)) {\n        throw new SerializationError(`Value is an array`, value);\n      }\n\n      /*\n        This is what we'd like to do, but we can't because at least the Java client\n        does not understand by-value serialized interface types, so we'll have to\n        serialize by-reference. Additionally, serializing known properties would\n        cause problems when the return type of a method is a UNION of structs.\n        See: https://github.com/aws/jsii/issues/400\n\n      const props = propertiesOf(namedType);\n\n      return mapValues(value, (v, key) => {\n        if (!props[key]) { return undefined; } // Don't map if unknown property\n        return host.recurse(v, props[key].type);\n      });\n      */\n\n      host.debug('Returning value type by reference');\n      return host.objects.registerObject(value, EMPTY_OBJECT_FQN, [\n        (optionalValue.type as spec.NamedTypeReference).fqn,\n      ]);\n    },\n    deserialize(value, optionalValue, host) {\n      if (typeof value === 'object' && Object.keys(value ?? {}).length === 0) {\n        // Treat empty structs as `undefined` (see https://github.com/aws/jsii/issues/411)\n        value = undefined;\n      }\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (typeof value !== 'object' || value == null) {\n        throw new SerializationError(`Value is not an object`, value);\n      }\n\n      const namedType = host.lookupType(\n        (optionalValue.type as spec.NamedTypeReference).fqn,\n      );\n      const props = propertiesOf(namedType, host.lookupType);\n\n      if (Array.isArray(value)) {\n        throw new SerializationError(\n          'Value is an array (varargs may have been incorrectly supplied)',\n          value,\n        );\n      }\n\n      // Similarly to serialization, we might be getting a reference type where we're\n      // expecting a value type. Accept this for now (but also validate that object\n      // for presence of the right properties).\n      if (isObjRef(value)) {\n        host.debug(\n          'Expected value type but got reference type, accepting for now (awslabs/jsii#400)',\n        );\n\n        // Return same INSTANCE (shouldn't matter but we don't know for sure that it doesn't)\n        return validateRequiredProps(\n          host.objects.findObject(value).instance,\n          namedType.fqn,\n          props,\n        );\n      }\n\n      if (api.isWireStruct(value)) {\n        const { fqn, data } = value[api.TOKEN_STRUCT];\n        if (!isAssignable(fqn, namedType, host.lookupType)) {\n          throw new SerializationError(\n            `Wired struct has type '${fqn}', which does not match expected type`,\n            value,\n          );\n        }\n        value = data;\n      }\n\n      // Python, for example, allows using plain mapping objects instead of Structs (dyanmic typing, YOLO!)\n      if (api.isWireMap(value)) {\n        value = value[api.TOKEN_MAP];\n      }\n\n      value = validateRequiredProps(value as any, namedType.fqn, props);\n\n      // Return a dict COPY, we have by-value semantics anyway.\n      return mapValues(value, (v, key) => {\n        if (!props[key]) {\n          return undefined;\n        } // Don't map if unknown property\n        return process(\n          host,\n          'deserialize',\n          v,\n          props[key],\n          `key ${inspect(key)}`,\n        );\n      });\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.ReferenceType]: {\n    serialize(value, optionalValue, host): ObjRef | undefined {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      if (typeof value !== 'object' || value == null || Array.isArray(value)) {\n        throw new SerializationError(`Value is not an object`, value);\n      }\n\n      if (value instanceof Date) {\n        throw new SerializationError(`Value is a Date`, value);\n      }\n\n      const expectedType = host.lookupType(\n        (optionalValue.type as spec.NamedTypeReference).fqn,\n      );\n      const interfaces = spec.isInterfaceType(expectedType)\n        ? [expectedType.fqn]\n        : undefined;\n      const jsiiType =\n        jsiiTypeFqn(value) ??\n        (spec.isClassType(expectedType) ? expectedType.fqn : EMPTY_OBJECT_FQN);\n\n      return host.objects.registerObject(value, jsiiType, interfaces);\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      assert(optionalValue !== VOID, 'Encountered unexpected void type!');\n\n      // The only way to pass a by-ref object is to have created it\n      // previously inside JSII kernel, so it must have an objref already.\n\n      if (!isObjRef(value)) {\n        throw new SerializationError(\n          `Value does not have the \"${TOKEN_REF}\" key`,\n          value,\n        );\n      }\n\n      const { instance, fqn } = host.objects.findObject(value);\n\n      const namedTypeRef = optionalValue.type as spec.NamedTypeReference;\n      if (namedTypeRef.fqn !== EMPTY_OBJECT_FQN) {\n        const namedType = host.lookupType(namedTypeRef.fqn);\n\n        // Check that the object we got is of the right type\n        // We only do this for classes, not interfaces, since Java might pass us objects that\n        // privately implement some interface and we can't prove they don't.\n        // https://github.com/aws/jsii/issues/399\n        const declaredType = optionalValue.type as spec.NamedTypeReference;\n        if (\n          spec.isClassType(namedType) &&\n          !isAssignable(fqn, declaredType, host.lookupType)\n        ) {\n          throw new SerializationError(\n            `Object of type '${fqn}' is not convertible to ${spec.describeTypeReference(\n              declaredType,\n            )}`,\n            value,\n          );\n        }\n      }\n\n      return instance;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Any]: {\n    serialize(value, _type, host) {\n      if (value == null) {\n        return undefined;\n      }\n\n      if (isDate(value)) {\n        return serializeDate(value);\n      }\n      if (isScalar(value)) {\n        return value;\n      }\n      if (Array.isArray(value)) {\n        return value.map((e, idx) =>\n          process(\n            host,\n            'serialize',\n            e,\n            { type: spec.CANONICAL_ANY },\n            `index ${inspect(idx)}`,\n          ),\n        );\n      }\n\n      // Note: no case for \"ENUM\" here, without type declaration we can't tell the difference\n      // between an enum member and a scalar.\n\n      if (typeof value === 'function') {\n        throw new SerializationError(\n          'Functions cannot be passed across language boundaries',\n          value,\n        );\n      }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new SerializationError(\n          `A jsii kernel assumption was violated: value is not an object`,\n          value,\n        );\n      }\n\n      if (\n        SYMBOL_WIRE_TYPE in value &&\n        (value as any)[SYMBOL_WIRE_TYPE] === TOKEN_MAP\n      ) {\n        return SERIALIZERS[SerializationClass.Map].serialize(\n          value,\n          {\n            type: {\n              collection: {\n                kind: spec.CollectionKind.Map,\n                elementtype: spec.CANONICAL_ANY,\n              },\n            },\n          },\n          host,\n        );\n      }\n\n      // To make sure people aren't going to try and return Map<> or Set<> out, test for\n      // those and throw a descriptive error message. We can't detect these cases any other\n      // way, and the by-value serialized object will be quite useless.\n      if (value instanceof Set || value instanceof Map) {\n        throw new SerializationError(\n          'Set and Map instances cannot be sent across the language boundary',\n          value,\n        );\n      }\n\n      // Use a previous reference to maintain object identity. NOTE: this may cause us to return\n      // a different type than requested! This is just how it is right now.\n      // https://github.com/aws/jsii/issues/399\n      const prevRef = objectReference(value);\n      if (prevRef) {\n        return prevRef;\n      }\n\n      // If this is or should be a reference type, pass or make the reference\n      // (Like regular reftype serialization, but without the type derivation to an interface)\n      const jsiiType =\n        jsiiTypeFqn(value) ??\n        (isByReferenceOnly(value) ? EMPTY_OBJECT_FQN : undefined);\n      if (jsiiType) {\n        return host.objects.registerObject(value, jsiiType);\n      }\n\n      // At this point we have an object that is not of an exported type. Either an object\n      // literal, or an instance of a fully private class (cannot distinguish those cases).\n\n      // We will serialize by-value, but recurse for serialization so that if\n      // the object contains reference objects, they will be serialized appropriately.\n      // (Basically, serialize anything else as a map of 'any').\n      return mapValues(value, (v, key) =>\n        process(\n          host,\n          'serialize',\n          v,\n          { type: spec.CANONICAL_ANY },\n          `key ${inspect(key)}`,\n        ),\n      );\n    },\n\n    deserialize(value, _type, host) {\n      if (value == null) {\n        return undefined;\n      }\n\n      if (isWireDate(value)) {\n        host.debug('ANY is a Date');\n        return deserializeDate(value);\n      }\n      if (isScalar(value)) {\n        host.debug('ANY is a Scalar');\n        return value;\n      }\n      if (Array.isArray(value)) {\n        host.debug('ANY is an Array');\n        return value.map((e, idx) =>\n          process(\n            host,\n            'deserialize',\n            e,\n            { type: spec.CANONICAL_ANY },\n            `index ${inspect(idx)}`,\n          ),\n        );\n      }\n\n      if (isWireEnum(value)) {\n        host.debug('ANY is an Enum');\n        return deserializeEnum(value, host.findSymbol);\n      }\n      if (isWireMap(value)) {\n        host.debug('ANY is a Map');\n        const mapOfAny: spec.CollectionTypeReference = {\n          collection: {\n            kind: spec.CollectionKind.Map,\n            elementtype: spec.CANONICAL_ANY,\n          },\n        };\n        return SERIALIZERS[SerializationClass.Map].deserialize(\n          value,\n          { type: mapOfAny },\n          host,\n        );\n      }\n      if (isObjRef(value)) {\n        host.debug('ANY is a Ref');\n        return host.objects.findObject(value).instance;\n      }\n\n      // if the value has a struct token, it was serialized by a typed jsii\n      // struct, but since the deserialization target is ANY, all we can do is\n      // strip the data from $jsii.struct and continue to deserialize as ANY.\n      if (isWireStruct(value)) {\n        const { fqn, data } = value[TOKEN_STRUCT];\n        host.debug(`ANY is a struct of type ${fqn}`);\n        return SERIALIZERS[SerializationClass.Struct].deserialize(\n          data,\n          { type: { fqn } },\n          host,\n        );\n      }\n\n      // At this point again, deserialize by-value.\n      host.debug('ANY is a Map');\n      return mapValues(value, (v, key) =>\n        process(\n          host,\n          'deserialize',\n          v,\n          { type: spec.CANONICAL_ANY },\n          `key ${inspect(key)}`,\n        ),\n      );\n    },\n  },\n};\n\nfunction serializeDate(value: Date): WireDate {\n  return { [TOKEN_DATE]: value.toISOString() };\n}\n\nfunction deserializeDate(value: WireDate): Date {\n  return new Date(value[TOKEN_DATE]);\n}\n\nfunction deserializeEnum(value: WireEnum, lookup: SymbolLookup) {\n  const enumLocator = value[TOKEN_ENUM];\n  const sep = enumLocator.lastIndexOf('/');\n  if (sep === -1) {\n    throw new SerializationError(\n      `Invalid enum token value ${inspect(enumLocator)}`,\n      value,\n    );\n  }\n\n  const typeName = enumLocator.slice(0, sep);\n  const valueName = enumLocator.slice(sep + 1);\n\n  const enumValue = lookup(typeName)[valueName];\n  if (enumValue === undefined) {\n    throw new SerializationError(\n      `No such enum member: ${inspect(valueName)}`,\n      value,\n    );\n  }\n  return enumValue;\n}\n\nexport interface TypeSerialization {\n  serializationClass: SerializationClass;\n  typeRef: OptionalValueOrVoid;\n}\n\n/**\n * From a type reference, return the possible serialization types\n *\n * There can be multiple, because the type can be a type union.\n */\nexport function serializationType(\n  typeRef: OptionalValueOrVoid,\n  lookup: TypeLookup,\n): TypeSerialization[] {\n  assert(\n    typeRef != null,\n    `Kernel error: expected type information, got ${inspect(typeRef)}`,\n  );\n\n  if (typeRef === 'void') {\n    return [{ serializationClass: SerializationClass.Void, typeRef }];\n  }\n  if (spec.isPrimitiveTypeReference(typeRef.type)) {\n    switch (typeRef.type.primitive) {\n      case spec.PrimitiveType.Any:\n        return [{ serializationClass: SerializationClass.Any, typeRef }];\n      case spec.PrimitiveType.Date:\n        return [{ serializationClass: SerializationClass.Date, typeRef }];\n      case spec.PrimitiveType.Json:\n        return [{ serializationClass: SerializationClass.Json, typeRef }];\n      case spec.PrimitiveType.Boolean:\n      case spec.PrimitiveType.Number:\n      case spec.PrimitiveType.String:\n        return [{ serializationClass: SerializationClass.Scalar, typeRef }];\n    }\n\n    assert(false, `Unknown primitive type: ${inspect(typeRef.type)}`);\n  }\n  if (spec.isCollectionTypeReference(typeRef.type)) {\n    return [\n      {\n        serializationClass:\n          typeRef.type.collection.kind === spec.CollectionKind.Array\n            ? SerializationClass.Array\n            : SerializationClass.Map,\n        typeRef,\n      },\n    ];\n  }\n  if (spec.isUnionTypeReference(typeRef.type)) {\n    const compoundTypes = flatMap(typeRef.type.union.types, (t) =>\n      serializationType({ type: t }, lookup),\n    );\n    // Propagate the top-level 'optional' field to each individual subtype\n    for (const t of compoundTypes) {\n      if (t.typeRef !== 'void') {\n        t.typeRef.optional = typeRef.optional;\n      }\n    }\n    return compoundTypes.sort((l, r) =>\n      compareSerializationClasses(l.serializationClass, r.serializationClass),\n    );\n  }\n\n  // The next part of the conversion is lookup-dependent\n  const type = lookup(typeRef.type.fqn);\n\n  if (spec.isEnumType(type)) {\n    return [{ serializationClass: SerializationClass.Enum, typeRef }];\n  }\n\n  if (spec.isInterfaceType(type) && type.datatype) {\n    return [{ serializationClass: SerializationClass.Struct, typeRef }];\n  }\n\n  return [{ serializationClass: SerializationClass.ReferenceType, typeRef }];\n}\n\nfunction nullAndOk(x: unknown, type: OptionalValueOrVoid): boolean {\n  if (x != null) {\n    return false;\n  }\n\n  if (type !== 'void' && !type.optional) {\n    throw new SerializationError(\n      `A value is required (type is non-optional)`,\n      x,\n    );\n  }\n\n  return true;\n}\n\nfunction isDate(x: unknown): x is Date {\n  return (\n    typeof x === 'object' &&\n    Object.prototype.toString.call(x) === '[object Date]'\n  );\n}\n\nfunction isScalar(x: unknown): x is string | number | boolean {\n  return (\n    typeof x === 'string' || typeof x === 'number' || typeof x === 'boolean'\n  );\n}\n\nfunction flatMap<T, U>(xs: T[], fn: (x: T) => U[]): U[] {\n  const ret = new Array<U>();\n  for (const x of xs) {\n    ret.push(...fn(x));\n  }\n  return ret;\n}\n\n/**\n * Map an object's values, skipping 'undefined' values'\n */\nfunction mapValues(\n  value: unknown,\n  fn: (value: any, field: string) => any,\n): { [key: string]: any } {\n  if (typeof value !== 'object' || value == null) {\n    throw new SerializationError(`Value is not an object`, value);\n  }\n\n  if (Array.isArray(value)) {\n    throw new SerializationError(`Value is an array`, value);\n  }\n\n  const out: { [key: string]: any } = {};\n  for (const [k, v] of Object.entries(value)) {\n    const wireValue = fn(v, k);\n    if (wireValue === undefined) {\n      continue;\n    }\n    out[k] = wireValue;\n  }\n  return out;\n}\n\nfunction propertiesOf(\n  t: spec.Type,\n  lookup: TypeLookup,\n): { [name: string]: spec.Property } {\n  if (!spec.isClassOrInterfaceType(t)) {\n    return {};\n  }\n\n  let ret: { [name: string]: spec.Property } = {};\n\n  if (t.interfaces) {\n    for (const iface of t.interfaces) {\n      ret = { ...ret, ...propertiesOf(lookup(iface), lookup) };\n    }\n  }\n  if (spec.isClassType(t) && t.base) {\n    ret = { ...ret, ...propertiesOf(lookup(t.base), lookup) };\n  }\n\n  for (const prop of t.properties ?? []) {\n    ret[prop.name] = prop;\n  }\n\n  return ret;\n}\n\n/**\n * Tests whether a given type (by it's FQN) can be assigned to a named type reference.\n *\n * @param actualTypeFqn the FQN of the type that is being tested.\n * @param requiredType  the required reference type.\n *\n * @returns true if ``requiredType`` is a super-type (base class or implemented interface) of the type designated by\n *          ``actualTypeFqn``.\n */\nfunction isAssignable(\n  actualTypeFqn: string,\n  requiredType: spec.NamedTypeReference,\n  lookup: TypeLookup,\n): boolean {\n  // The empty object is assignable to everything\n  if (actualTypeFqn === EMPTY_OBJECT_FQN) {\n    return true;\n  }\n\n  if (requiredType.fqn === actualTypeFqn) {\n    return true;\n  }\n  const actualType = lookup(actualTypeFqn);\n  if (spec.isClassType(actualType)) {\n    if (\n      actualType.base &&\n      isAssignable(actualType.base, requiredType, lookup)\n    ) {\n      return true;\n    }\n  }\n  if (spec.isClassOrInterfaceType(actualType) && actualType.interfaces) {\n    return (\n      actualType.interfaces.find((iface) =>\n        isAssignable(iface, requiredType, lookup),\n      ) != null\n    );\n  }\n  return false;\n}\n\nfunction validateRequiredProps(\n  actualProps: { [key: string]: any },\n  typeName: string,\n  specProps: { [key: string]: spec.Property },\n) {\n  // Check for required properties\n  const missingRequiredProps = Object.keys(specProps)\n    .filter((name) => !specProps[name].optional)\n    .filter((name) => !(name in actualProps));\n\n  if (missingRequiredProps.length > 0) {\n    throw new SerializationError(\n      `Missing required properties for ${typeName}: ${missingRequiredProps\n        .map((p) => inspect(p))\n        .join(', ')}`,\n      actualProps,\n    );\n  }\n\n  return actualProps;\n}\n\nfunction compareSerializationClasses(\n  l: SerializationClass,\n  r: SerializationClass,\n): number {\n  const order = [\n    SerializationClass.Void,\n    SerializationClass.Date,\n    SerializationClass.Scalar,\n    SerializationClass.Json,\n    SerializationClass.Enum,\n    SerializationClass.Array,\n    SerializationClass.Map,\n    SerializationClass.Struct,\n    SerializationClass.ReferenceType,\n    SerializationClass.Any,\n  ];\n  return order.indexOf(l) - order.indexOf(r);\n}\n\n/**\n * Determines whether `obj` must be passed by-reference or if by-value is acceptable. For example,\n * objects with methods, or dynamic getters (or setters) should be passed by-reference as a matter\n * of security. The behavior in non-JS runtimes could otherwise differ from that in pure JS (if\n * getters are not stable, etc...).\n *\n * @param obj the object to be tested.\n *\n * @returns true if `obj` must be passed by-reference.\n */\nfunction isByReferenceOnly(obj: any): boolean {\n  if (Array.isArray(obj)) {\n    return false;\n  }\n\n  let curr = obj;\n  // Crawl up the prototype chain to look for dynamic properties or methods.\n  do {\n    for (const prop of Object.getOwnPropertyNames(curr)) {\n      const descr = Object.getOwnPropertyDescriptor(curr, prop);\n      if (\n        descr?.get != null ||\n        descr?.set != null ||\n        typeof descr?.value === 'function'\n      ) {\n        // Property has a dynamic getter, setter or is a constructor/method, so by-ref required!\n        return true;\n      }\n    }\n    // End when the parent proto is `Object`, which has no parent proto itself.\n  } while (Object.getPrototypeOf((curr = Object.getPrototypeOf(curr))) != null);\n\n  return false;\n}\n\nexport function process(\n  host: SerializerHost,\n  serde: keyof Serializer,\n  value: unknown,\n  type: OptionalValueOrVoid,\n  context: string,\n) {\n  const wireTypes = serializationType(type, host.lookupType);\n  host.debug(serde, value, wireTypes);\n\n  const errors = new Array<any>();\n  for (const { serializationClass, typeRef } of wireTypes) {\n    try {\n      return SERIALIZERS[serializationClass][serde](value, typeRef, host);\n    } catch (error: any) {\n      error.context = `as ${\n        typeRef === VOID ? VOID : spec.describeTypeReference(typeRef.type)\n      }`;\n      errors.push(error);\n    }\n  }\n\n  const typeDescr =\n    type === VOID ? type : spec.describeTypeReference(type.type);\n  const optionalTypeDescr =\n    type !== VOID && type.optional ? `${typeDescr} | undefined` : typeDescr;\n  throw new SerializationError(\n    `${titleize(context)}: Unable to ${serde} value as ${optionalTypeDescr}`,\n    value,\n    errors,\n    { renderValue: true },\n  );\n\n  function titleize(text: string): string {\n    text = text.trim();\n    if (text === '') {\n      return text;\n    }\n    const [first, ...rest] = text;\n    return [first.toUpperCase(), ...rest].join('');\n  }\n}\n\nexport class SerializationError extends Error {\n  public readonly name: string = '@jsii/kernel.SerializationError';\n\n  public constructor(\n    message: string,\n    public readonly value: unknown,\n    public readonly causes: readonly any[] = [],\n    { renderValue = false }: { renderValue?: boolean } = {},\n  ) {\n    super(\n      [\n        message,\n        ...(renderValue\n          ? [\n              `${\n                causes.length > 0 ? '\\u{251C}' : '\\u{2570}'\n              }\\u{2500}\\u{2500} \\u{1F6D1} Failing value is ${describeTypeOf(\n                value,\n              )}`,\n              ...(value == null\n                ? []\n                : inspect(value, false, 0)\n                    .split('\\n')\n                    .map(\n                      (l) =>\n                        `${causes.length > 0 ? '\\u{2502}' : ' '}      ${l}`,\n                    )),\n            ]\n          : []),\n        ...(causes.length > 0\n          ? [\n              '\\u{2570}\\u{2500}\\u{2500} \\u{1F50D} Failure reason(s):',\n              ...causes.map(\n                (cause, idx) =>\n                  `    ${\n                    idx < causes.length - 1 ? '\\u{251C}' : '\\u{2570}'\n                  }\\u{2500}${\n                    causes.length > 1\n                      ? ` [${cause.context ?? inspect(idx)}]`\n                      : ''\n                  } ${cause.message.split('\\n').join('\\n        ')}`,\n              ),\n            ]\n          : []),\n      ].join('\\n'),\n    );\n  }\n}\n\nfunction describeTypeOf(value: unknown) {\n  const type = typeof value;\n  switch (type) {\n    case 'object':\n      if (value == null) {\n        return JSON.stringify(value);\n      }\n\n      if (Array.isArray(value)) {\n        return 'an array';\n      }\n\n      const fqn = jsiiTypeFqn(value as object);\n      if (fqn != null && fqn !== EMPTY_OBJECT_FQN) {\n        return `an instance of ${fqn}`;\n      }\n\n      const ctorName = (value as object).constructor.name;\n      if (ctorName != null && ctorName !== Object.name) {\n        return `an instance of ${ctorName}`;\n      }\n\n      return `an object`;\n\n    case 'undefined':\n      return type;\n\n    case 'boolean':\n    case 'function':\n    case 'number':\n    case 'string':\n    default:\n      return `a ${type}`;\n  }\n}\n","import { tmpdir } from 'os';\nimport { join } from 'path';\n\nexport function defaultCacheRoot(): string {\n  switch (process.platform) {\n    case 'darwin':\n      if (process.env.HOME)\n        return join(\n          process.env.HOME,\n          'Library',\n          'Caches',\n          'com.amazonaws.jsii',\n          'package-cache',\n        );\n      break;\n    case 'linux':\n      if (process.env.HOME)\n        return join(process.env.HOME, '.cache', 'aws', 'jsii', 'package-cache');\n      break;\n    case 'win32':\n      if (process.env.LOCALAPPDATA)\n        return join(process.env.LOCALAPPDATA, 'AWS', 'jsii', 'package-cache');\n      break;\n    default:\n    // Fall back on putting in tmpdir()\n  }\n  return join(tmpdir(), 'aws-jsii-package-cache');\n}\n","import { mkdirSync, mkdtempSync, renameSync, rmSync } from 'fs';\nimport { tmpdir } from 'os';\nimport { join } from 'path';\nimport * as tar from 'tar';\n\nimport { DiskCache } from '../disk-cache';\nimport { defaultCacheRoot } from './default-cache-root';\n\nexport type ExtractOptions = Omit<\n  tar.ExtractOptions & tar.FileOptions,\n  'file' | 'cwd'\n>;\n\nexport interface ExtractResult {\n  /**\n   * The path in which the extracted files are located\n   */\n  readonly path: string;\n\n  /**\n   * When `'hit'`, the data was already present in cache and was returned from\n   * cache.\n   *\n   * When `'miss'`, the data was extracted into the caache and returned from\n   * cache.\n   *\n   * When `undefined`, the cache is not enabled.\n   */\n  readonly cache?: 'hit' | 'miss';\n}\n\nlet packageCacheEnabled =\n  process.env.JSII_RUNTIME_PACKAGE_CACHE?.toLocaleUpperCase() === 'enabled';\n\n/**\n * Extracts the content of a tarball, possibly caching it on disk.\n *\n * @param file     is the path to the tarball to be extracted.\n * @param options  are options to pass to `tar.extract`\n * @param comments are included in the cache key, when caching is enabled.\n *\n * @returns the result of the extraction.\n */\nexport function extract(\n  file: string,\n  options: ExtractOptions,\n  ...comments: readonly string[]\n): ExtractResult {\n  return (packageCacheEnabled ? extractToCache : extractToTemporary)(\n    file,\n    options,\n    ...comments,\n  );\n}\n\nfunction extractToCache(\n  file: string,\n  options: ExtractOptions = {},\n  ...comments: readonly string[]\n): { path: string; cache: 'hit' | 'miss' } {\n  const cacheRoot =\n    process.env.JSII_RUNTIME_PACKAGE_CACHE_ROOT ?? defaultCacheRoot();\n  const cache = DiskCache.inDirectory(cacheRoot);\n\n  const entry = cache.entryFor(file, ...comments);\n  return entry.lock((lock) => {\n    let cache: 'hit' | 'miss' = 'hit';\n    if (!entry.pathExists) {\n      const tmpPath = `${entry.path}.tmp`;\n      mkdirSync(tmpPath, { recursive: true });\n      try {\n        untarInto({\n          ...options,\n          cwd: tmpPath,\n          file,\n        });\n        renameSync(tmpPath, entry.path);\n      } catch (error) {\n        rmSync(entry.path, { force: true, recursive: true });\n        throw error;\n      }\n      cache = 'miss';\n    }\n    lock.touch();\n    return { path: entry.path, cache };\n  });\n}\n\nfunction extractToTemporary(\n  file: string,\n  options: ExtractOptions = {},\n): { path: string } {\n  const path = mkdtempSync(join(tmpdir(), 'jsii-runtime-untar-'));\n\n  untarInto({ ...options, cwd: path, file });\n\n  return { path };\n}\n\nfunction untarInto(\n  options: tar.ExtractOptions & tar.FileOptions & { cwd: string },\n) {\n  try {\n    tar.extract({ ...options, sync: true });\n  } catch (error) {\n    rmSync(options.cwd, { force: true, recursive: true });\n    throw error;\n  }\n}\n\n/** @internal */\nexport function getPackageCacheEnabled(): boolean {\n  return packageCacheEnabled;\n}\n\n/** @internal */\nexport function setPackageCacheEnabled(value: boolean) {\n  packageCacheEnabled = value;\n}\n","import { api, Kernel } from '@jsii/kernel';\nimport { EventEmitter } from 'events';\n\nimport { Input, IInputOutput } from './in-out';\n\nexport class KernelHost {\n  private readonly kernel = new Kernel(this.callbackHandler.bind(this));\n  private readonly eventEmitter = new EventEmitter();\n\n  public constructor(\n    private readonly inout: IInputOutput,\n    private readonly opts: {\n      debug?: boolean;\n      debugTiming?: boolean;\n      noStack?: boolean;\n    } = {},\n  ) {\n    this.kernel.traceEnabled = opts.debug ?? false;\n    this.kernel.debugTimingEnabled = opts.debugTiming ?? false;\n  }\n\n  public run() {\n    const req = this.inout.read();\n    if (!req || 'exit' in req) {\n      this.eventEmitter.emit('exit', req?.exit ?? 0);\n      return; // done\n    }\n\n    this.processRequest(req, () => {\n      // Schedule the call to run on the next event loop iteration to\n      // avoid recursion.\n      setImmediate(() => this.run());\n    });\n  }\n\n  public once(event: 'exit', listener: (code: number) => void) {\n    this.eventEmitter.once(event, listener);\n  }\n\n  private callbackHandler(callback: api.Callback) {\n    // write a \"callback\" response, which is a special response that tells\n    // the client that there's synchonous callback it needs to invoke and\n    // bring back the result via a \"complete\" request.\n    this.inout.write({ callback });\n\n    return completeCallback.call(this);\n\n    function completeCallback(this: KernelHost): void {\n      const req = this.inout.read();\n      if (!req || 'exit' in req) {\n        throw new Error('Interrupted before callback returned');\n      }\n\n      // if this is a completion for the current callback, then we can\n      // finally stop this nonsense and return the result.\n      const completeReq = req as { complete: api.CompleteRequest };\n      if (\n        'complete' in completeReq &&\n        completeReq.complete.cbid === callback.cbid\n      ) {\n        if (completeReq.complete.err) {\n          throw new Error(completeReq.complete.err);\n        }\n\n        return completeReq.complete.result;\n      }\n\n      // otherwise, process the request normally, but continue to wait for\n      // our callback to be completed. sync=true to enforce that `completeCallback`\n      // will be called synchronously and return value will be chained back so we can\n      // return it to the callback handler.\n      return this.processRequest(\n        req,\n        completeCallback.bind(this),\n        /* sync */ true,\n      );\n    }\n  }\n\n  /**\n   * Processes the input request `req` and writes the output response to\n   * stdout. This method invokes `next` when the request was fully processed.\n   * This either happens synchronously or asynchronously depending on the api\n   * (e.g. the \"end\" api will wait for an async promise to be fulfilled before\n   * it writes the response)\n   *\n   * @param req The input request\n   * @param next A callback to invoke to continue\n   * @param sync If this is 'true', \"next\" must be called synchronously. This means\n   *             that we won't process any async activity (begin/complete). The kernel\n   *             doesn't allow any async operations during a sync callback, so this shouldn't\n   *             happen, so we assert in this case to find bugs.\n   */\n  private processRequest(req: Input, next: () => void, sync = false) {\n    if ('callback' in req) {\n      throw new Error(\n        'Unexpected `callback` result. This request should have been processed by a callback handler',\n      );\n    }\n\n    if (!('api' in req)) {\n      throw new Error('Malformed request, \"api\" field is required');\n    }\n\n    const apiReq = req;\n    const fn = this.findApi(apiReq.api);\n\n    try {\n      const ret = fn.call(this.kernel, req);\n\n      // special case for 'begin' and 'complete' which are on an async\n      // promise path. in order to allow the kernel to actually fulfill\n      // the promise, and continue any async flows (which may potentially\n      // start other promises), we respond only within a setImmediate\n      // block, which is scheduled in the same micro-tasks queue as\n      // promises. see the kernel test 'async overrides: two overrides'\n      // for an example for this use case.\n      if (apiReq.api === 'begin' || apiReq.api === 'complete') {\n        checkIfAsyncIsAllowed();\n\n        this.debug('processing pending promises before responding');\n\n        setImmediate(() => {\n          this.writeOkay(ret);\n          next();\n        });\n\n        return undefined;\n      }\n\n      // if this is an async method, return immediately and\n      // call next only when the promise is fulfilled.\n      if (this.isPromise(ret)) {\n        checkIfAsyncIsAllowed();\n\n        this.debug('waiting for promise to be fulfilled');\n\n        const promise = ret;\n        promise\n          .then((val) => {\n            this.debug('promise succeeded:', val);\n            this.writeOkay(val);\n            next();\n          })\n          .catch((e) => {\n            this.debug('promise failed:', e);\n            this.writeError(e);\n            next();\n          });\n\n        return undefined;\n      }\n\n      this.writeOkay(ret);\n    } catch (e) {\n      this.writeError(e);\n    }\n\n    // indicate this request was processed (synchronously).\n    return next();\n\n    function checkIfAsyncIsAllowed() {\n      if (sync) {\n        throw new Error(\n          'Cannot handle async operations while waiting for a sync callback to return',\n        );\n      }\n    }\n  }\n\n  /**\n   * Writes an \"ok\" result to stdout.\n   */\n  private writeOkay(result: any) {\n    const res = { ok: result };\n    this.inout.write(res);\n  }\n\n  /**\n   * Writes an \"error\" result to stdout.\n   */\n  private writeError(error: any) {\n    const res = { error: error.message, stack: undefined };\n    if (!this.opts.noStack) {\n      res.stack = error.stack;\n    }\n    this.inout.write(res);\n  }\n\n  /**\n   * Returns true if the value is a promise.\n   */\n  private isPromise(v: any): v is Promise<any> {\n    return typeof v?.then === 'function';\n  }\n\n  /**\n   * Given a kernel api name, returns the function to invoke.\n   */\n  private findApi(apiName: string): (this: Kernel, arg: Input) => any {\n    const fn = (this.kernel as any)[apiName];\n    if (typeof fn !== 'function') {\n      throw new Error(`Invalid kernel api call: ${apiName}`);\n    }\n    return fn;\n  }\n\n  private debug(...args: any[]) {\n    if (!this.opts.debug) {\n      return;\n    }\n\n    console.error(...args);\n  }\n}\n","import { api } from '@jsii/kernel';\n\nimport { SyncStdio } from './sync-stdio';\n\nexport type Output =\n  | { hello: string }\n  | { ok: api.KernelResponse }\n  | { callback: api.Callback }\n  | { pending: true }\n  | { error: string; stack?: string };\n\nexport type Input =\n  | ({ api: string } & api.KernelRequest)\n  | { complete: api.CompleteRequest };\n\nexport type Exit = { exit: number };\n\n/**\n * An IO provider for jsii API exchanges.\n */\nexport interface IInputOutput {\n  /**\n   * Writes a message to the jsii API host.\n   * @param message the message to be sent.\n   */\n  write(message: Output): void;\n\n  /**\n   * Wait for a message from the jsii API host, then return it.\n   *\n   * @returns the received message, or `undefined` if the API host has no more\n   *          requests to send.\n   */\n  read(): Input | Exit | undefined;\n}\n\nexport class InputOutput implements IInputOutput {\n  public debug = false;\n\n  public constructor(private readonly stdio: SyncStdio) {}\n\n  public write(obj: Output) {\n    const output = JSON.stringify(obj);\n    this.stdio.writeLine(output);\n\n    if (this.debug) {\n      this.stdio.writeErrorLine(`< ${output}`);\n    }\n  }\n\n  public read(): Input | undefined {\n    let reqLine = this.stdio.readLine();\n    if (!reqLine) {\n      return undefined;\n    }\n\n    // skip recorded responses\n    if (reqLine.startsWith('< ')) {\n      return this.read();\n    }\n\n    // stip \"> \" from recorded requests\n    if (reqLine.startsWith('> ')) {\n      reqLine = reqLine.slice(2);\n    }\n\n    const input = JSON.parse(reqLine);\n\n    if (this.debug) {\n      this.stdio.writeErrorLine(`> ${JSON.stringify(input)}`);\n    }\n\n    return input;\n  }\n}\n","import * as fs from 'fs';\n\nconst INPUT_BUFFER_SIZE = 1_048_576; // 1MiB (aka: 1024 * 1024), not related to max line length\n\nexport class SyncStdio {\n  private bufferedData = Buffer.alloc(0);\n\n  private readonly stderr: number;\n  private readonly stdin: number;\n  private readonly stdout: number;\n\n  // A buffer that will be used for all reading operations.\n  private readonly readBuffer = Buffer.alloc(INPUT_BUFFER_SIZE);\n\n  public constructor({ errorFD, readFD, writeFD }: SyncStdioOptions) {\n    this.stderr = errorFD;\n    this.stdin = readFD;\n    this.stdout = writeFD;\n  }\n\n  public writeErrorLine(line: string) {\n    this.writeBuffer(Buffer.from(`${line}\\n`), this.stderr);\n  }\n\n  public writeLine(line: string) {\n    this.writeBuffer(Buffer.from(`${line}\\n`), this.stdout);\n  }\n\n  public readLine(): string | undefined {\n    while (!this.bufferedData.includes('\\n', 0, 'utf-8')) {\n      const read = fs.readSync(\n        this.stdin,\n        this.readBuffer,\n        0,\n        this.readBuffer.length,\n        null,\n      );\n\n      if (read === 0) {\n        return undefined;\n      }\n\n      const newData = this.readBuffer.slice(0, read);\n      this.bufferedData = Buffer.concat([this.bufferedData, newData]);\n    }\n\n    const newLinePos = this.bufferedData.indexOf('\\n', 0, 'utf-8');\n    const next = this.bufferedData.slice(0, newLinePos).toString('utf-8');\n    this.bufferedData = this.bufferedData.slice(newLinePos + 1);\n\n    return next;\n  }\n\n  private writeBuffer(buffer: Buffer, fd: number) {\n    let offset = 0;\n    while (offset < buffer.length) {\n      try {\n        offset += fs.writeSync(fd, buffer, offset);\n      } catch (e: any) {\n        // We might get EAGAIN if the file descriptor was not opened for\n        // blocking (O_SYNC) writes. In such cases, we'll keep trying until it\n        // succeeds. This shouldn't take long as the process on the other side\n        // is expected to actively wait for data on those pipes.\n        if (e.code !== 'EAGAIN') {\n          throw e;\n        }\n      }\n    }\n  }\n}\n\nexport interface SyncStdioOptions {\n  /**\n   * The file descriptor from which data is to be read. This MUST be opened for\n   * blocking (O_SYNC) reading.\n   */\n  readonly readFD: number;\n\n  /**\n   * The file descriptor to which data is to be written. This SHOULD be opened\n   * for blocking (O_SYNC) writing.\n   */\n  readonly writeFD: number;\n\n  /**\n   * The file descriptor to which errors data is to be written. This SHOULD be\n   * opened for blocking (O_SYNC) writing.\n   */\n  readonly errorFD: number;\n}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as zlib from 'zlib';\n\nimport {\n  Assembly,\n  SPEC_FILE_NAME,\n  SPEC_FILE_NAME_COMPRESSED,\n} from './assembly';\nimport {\n  AssemblyRedirect,\n  isAssemblyRedirect,\n  validateAssemblyRedirect,\n} from './redirect';\nimport { validateAssembly } from './validate-assembly';\n\n/**\n * Returns true if the SPEC_FILE_NAME_COMPRESSED file exists in the directory.\n */\nexport function compressedAssemblyExists(directory: string): boolean {\n  return fs.existsSync(path.join(directory, SPEC_FILE_NAME_COMPRESSED));\n}\n\n/**\n * Finds the path to the SPEC_FILE_NAME file, which will either\n * be the assembly or hold instructions to find the assembly.\n *\n * @param directory path to a directory with an assembly file\n * @returns path to the SPEC_FILE_NAME file\n */\nexport function findAssemblyFile(directory: string) {\n  const dotJsiiFile = path.join(directory, SPEC_FILE_NAME);\n\n  if (!fs.existsSync(dotJsiiFile)) {\n    throw new Error(\n      `Expected to find ${SPEC_FILE_NAME} file in ${directory}, but no such file found`,\n    );\n  }\n\n  return dotJsiiFile;\n}\n\n/**\n * Replaces the file where the original assembly file *should* be found with a new assembly file.\n * Detects whether or not there is a compressed assembly, and if there is, compresses the new assembly also.\n * Replaces the fingerprint with '**********' rather than recalculating it, since we have modified the assembly.\n */\nexport function replaceAssembly(assembly: Assembly, directory: string) {\n  writeAssembly(directory, _fingerprint(assembly), {\n    compress: compressedAssemblyExists(directory),\n  });\n}\n\n/**\n * Replaces the old fingerprint with '***********'.\n *\n * We could recalculate the fingerprint here so that it looks like the assembly was not modified. However,\n * 1) we are not actually validating the fingerprint in any way, and\n * 2) it feels disingenuous to have a mechanism against tampering and then tamper with it.\n *\n * So, instead of keeping the old (wrong) fingerprint or spending extra time calculating a new fingerprint,\n * we replace with '**********' that demonstrates the fingerprint has changed.\n */\nfunction _fingerprint(assembly: Assembly): Assembly {\n  assembly.fingerprint = '*'.repeat(10);\n  return assembly;\n}\n\n/**\n * Writes the assembly file either as .jsii or .jsii.gz if zipped\n *\n * @param directory the directory path to place the assembly file\n * @param assembly the contents of the assembly\n * @param compress whether or not to zip the assembly (.jsii.gz)\n * @returns whether or not the assembly was zipped\n */\nexport function writeAssembly(\n  directory: string,\n  assembly: Assembly,\n  { compress = false }: { compress?: boolean } = {},\n) {\n  if (compress) {\n    // write .jsii file with instructions on opening the compressed file\n    fs.writeFileSync(\n      path.join(directory, SPEC_FILE_NAME),\n      JSON.stringify({\n        schema: 'jsii/file-redirect',\n        compression: 'gzip',\n        filename: SPEC_FILE_NAME_COMPRESSED,\n      }),\n      'utf-8',\n    );\n\n    // write actual assembly contents in .jsii.gz\n    fs.writeFileSync(\n      path.join(directory, SPEC_FILE_NAME_COMPRESSED),\n      zlib.gzipSync(JSON.stringify(assembly)),\n    );\n  } else {\n    fs.writeFileSync(\n      path.join(directory, SPEC_FILE_NAME),\n      JSON.stringify(assembly, null, 2),\n      'utf-8',\n    );\n  }\n\n  return compress;\n}\n\nconst failNoReadfileProvided = (filename: string) => {\n  throw new Error(\n    `Unable to load assembly support file ${JSON.stringify(\n      filename,\n    )}: no readFile callback provided!`,\n  );\n};\n\n/**\n * Parses the assembly buffer and, if instructed to, redirects to the\n * compressed assembly buffer.\n *\n * @param assemblyBuffer buffer containing SPEC_FILE_NAME contents\n * @param readFile a callback to use for reading additional support files\n * @param validate whether or not to validate the assembly\n */\nexport function loadAssemblyFromBuffer(\n  assemblyBuffer: Buffer,\n  readFile: (filename: string) => Buffer = failNoReadfileProvided,\n  validate = true,\n): Assembly {\n  let contents = JSON.parse(assemblyBuffer.toString('utf-8'));\n\n  // check if the file holds instructions to the actual assembly file\n  while (isAssemblyRedirect(contents)) {\n    contents = followRedirect(contents, readFile);\n  }\n\n  return validate ? validateAssembly(contents) : contents;\n}\n\n/**\n * Loads the assembly file and, if present, follows instructions\n * found in the file to unzip compressed assemblies.\n *\n * @param directory the directory of the assembly file\n * @param validate whether to validate the contents of the file\n * @returns the assembly file as an Assembly object\n */\nexport function loadAssemblyFromPath(\n  directory: string,\n  validate = true,\n): Assembly {\n  const assemblyFile = findAssemblyFile(directory);\n  return loadAssemblyFromFile(assemblyFile, validate);\n}\n\n/**\n * Loads the assembly file and, if present, follows instructions\n * found in the file to unzip compressed assemblies.\n *\n * @param pathToFile the path to the SPEC_FILE_NAME file\n * @param validate whether to validate the contents of the file\n * @returns the assembly file as an Assembly object\n */\nexport function loadAssemblyFromFile(\n  pathToFile: string,\n  validate = true,\n): Assembly {\n  const data = fs.readFileSync(pathToFile);\n  return loadAssemblyFromBuffer(\n    data,\n    (filename) => fs.readFileSync(path.resolve(pathToFile, '..', filename)),\n    validate,\n  );\n}\n\nfunction followRedirect(\n  assemblyRedirect: AssemblyRedirect,\n  readFile: (filename: string) => Buffer,\n) {\n  // Validating the schema, this is cheap (the schema is small).\n  validateAssemblyRedirect(assemblyRedirect);\n\n  let data = readFile(assemblyRedirect.filename);\n  switch (assemblyRedirect.compression) {\n    case 'gzip':\n      data = zlib.gunzipSync(data);\n      break;\n    case undefined:\n      break;\n    default:\n      throw new Error(\n        `Unsupported compression algorithm: ${JSON.stringify(\n          assemblyRedirect.compression,\n        )}`,\n      );\n  }\n  const json = data.toString('utf-8');\n  return JSON.parse(json);\n}\n","/**\n * Expected file name for jsii assembly or instructions to compressed assembly.\n */\nexport const SPEC_FILE_NAME = '.jsii';\n\n/**\n * Expected file name for compressed assemblies.\n */\nexport const SPEC_FILE_NAME_COMPRESSED = `${SPEC_FILE_NAME}.gz`;\n\n/**\n * A JSII assembly specification.\n */\nexport interface Assembly\n  extends AssemblyConfiguration,\n    Documentable,\n    ReadMeContainer {\n  /**\n   * The version of the spec schema\n   */\n  schema: SchemaVersion.LATEST;\n\n  /**\n   * The name of the assembly\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * Description of the assembly, maps to \"description\" from package.json\n   * This is required since some package managers (like Maven) require it.\n   */\n  description: string;\n\n  /**\n   * The url to the project homepage. Maps to \"homepage\" from package.json.\n   */\n  homepage: string;\n\n  /**\n   * The module repository, maps to \"repository\" from package.json\n   * This is required since some package managers (like Maven) require it.\n   */\n  repository: {\n    /**\n     * The type of the repository (``git``, ``svn``, ...)\n     */\n    type: string;\n\n    /**\n     * The URL of the repository.\n     */\n    url: string;\n\n    /**\n     * If the package is not in the root directory (for example, when part\n     * of a monorepo), you should specify the directory in which it lives.\n     *\n     * @default the root of the repository\n     */\n    directory?: string;\n  };\n\n  /**\n   * The main author of this package.\n   */\n  author: Person;\n\n  /**\n   * Additional contributors to this package.\n   *\n   * @default none\n   */\n  contributors?: Person[];\n\n  /**\n   * A fingerprint that can be used to determine if the specification has\n   * changed.\n   *\n   * @minLength 1\n   */\n  fingerprint: string;\n\n  /**\n   * The version of the assembly\n   * @minLength 1\n   */\n  version: string;\n\n  /**\n   * The version of the jsii compiler that was used to produce this Assembly.\n   * @minLength 1\n   */\n  jsiiVersion: string;\n\n  /**\n   * The SPDX name of the license this assembly is distributed on.\n   */\n  license: string;\n\n  /**\n   * Arbitrary key-value pairs of metadata, which the maintainer chose to\n   * document with the assembly. These entries do not carry normative\n   * semantics and their interpretation is up to the assembly maintainer.\n   *\n   * @default none\n   */\n  metadata?: { [key: string]: any };\n\n  /**\n   * Keywords that help discover or identify this packages with respects to it's\n   * intended usage, audience, etc... Where possible, this will be rendered in\n   * the corresponding metadata section of idiomatic package manifests, for\n   * example NuGet package tags.\n   */\n  keywords?: string[];\n\n  /**\n   * Direct dependencies on other assemblies (with semver), the key is the JSII\n   * assembly name, and the value is a SemVer expression.\n   *\n   * @default none\n   */\n  dependencies?: { [assembly: string]: string };\n\n  /**\n   * Target configuration for all the assemblies that are direct or transitive\n   * dependencies of this assembly. This is needed to generate correct native\n   * type names for any transitively inherited member, in certain languages.\n   *\n   * @default none\n   */\n  dependencyClosure?: { [assembly: string]: DependencyConfiguration };\n\n  /**\n   * List if bundled dependencies (these are not expected to be jsii\n   * assemblies).\n   *\n   * @default none\n   */\n  bundled?: { [module: string]: string };\n\n  /**\n   * All types in the assembly, keyed by their fully-qualified-name\n   *\n   * @default none\n   */\n  types?: { [fqn: string]: Type };\n\n  /**\n   * List of bin-scripts\n   *\n   * @default none\n   */\n  bin?: { readonly [script: string]: string };\n}\n\n/**\n * Shareable configuration of a jsii Assembly.\n */\nexport interface AssemblyConfiguration extends Targetable {\n  /**\n   * Submodules declared in this assembly.\n   *\n   * @default none\n   */\n  submodules?: { [fqn: string]: Submodule };\n}\n\nexport interface DependencyConfiguration extends Targetable {\n  submodules?: { [fqn: string]: Targetable };\n}\n\n/**\n * A targetable module-like thing\n *\n * Has targets and a readme. Used for Assemblies and Submodules.\n */\nexport interface Targetable {\n  /**\n   * A map of target name to configuration, which is used when generating\n   * packages for various languages.\n   *\n   * @default none\n   */\n  targets?: AssemblyTargets;\n}\n\n/**\n * Elements that can contain a `readme` property.\n */\nexport interface ReadMeContainer {\n  /**\n   * The readme document for this module (if any).\n   *\n   * @default none\n   */\n  readme?: ReadMe;\n}\n\n/**\n * README information\n */\nexport interface ReadMe {\n  markdown: string;\n}\n\n/**\n * A submodule\n *\n * The difference between a top-level module (the assembly) and a submodule is\n * that the submodule is annotated with its location in the repository.\n */\nexport type Submodule = ReadMeContainer &\n  SourceLocatable &\n  Targetable &\n  TypeScriptLocatable;\n\n/**\n * Versions of the JSII Assembly Specification.\n */\nexport enum SchemaVersion {\n  LATEST = 'jsii/0.10.0',\n}\n\n/**\n * Fully Qualified Name\n */\nexport type FQN = string;\n\n/**\n * Metadata about people or organizations associated with the project that\n * resulted in the Assembly. Some of this metadata is required in order to\n * publish to certain package repositories (for example, Maven Central), but is\n * not normalized, and the meaning of fields (role, for example), is up to each\n * project maintainer.\n */\nexport interface Person {\n  /**\n   * The name of the person\n   */\n  name: string;\n\n  /**\n   * A list of roles this person has in the project, for example `maintainer`,\n   * `contributor`, `owner`, ...\n   */\n  roles: string[];\n\n  /**\n   * The email of the person\n   *\n   * @default none\n   */\n  email?: string;\n\n  /**\n   * The URL for the person\n   *\n   * @default none\n   */\n  url?: string;\n\n  /**\n   * If true, this person is, in fact, an organization\n   *\n   * @default false\n   */\n  organization?: boolean;\n}\n\n/**\n * Configurable targets for an asembly.\n */\nexport interface AssemblyTargets {\n  /**\n   * Information about a particular language's targets\n   */\n  [language: string]: { [key: string]: any } | undefined;\n}\n\n/**\n * Where in the module source the definition for this API item was found\n */\nexport interface SourceLocation {\n  /**\n   * Relative filename\n   */\n  filename: string;\n\n  /**\n   * 1-based line number in the indicated file\n   */\n  line: number;\n}\n\n/**\n * Key value pairs of documentation nodes.\n * Based on TSDoc.\n */\nexport interface Docs {\n  /**\n   * Summary documentation for an API item.\n   *\n   * The first part of the documentation before hitting a `@remarks` tags, or\n   * the first line of the doc comment block if there is no `@remarks` tag.\n   *\n   * @default none\n   */\n  summary?: string;\n\n  /**\n   * Detailed information about an API item.\n   *\n   * Either the explicitly tagged `@remarks` section, otherwise everything\n   * past the first paragraph if there is no `@remarks` tag.\n   *\n   * @default none\n   */\n  remarks?: string;\n\n  /**\n   * If present, this block indicates that an API item is no longer supported\n   * and may be removed in a future release.  The `@deprecated` tag must be\n   * followed by a sentence describing the recommended alternative.\n   * Deprecation recursively applies to members of a container. For example,\n   * if a class is deprecated, then so are all of its members.\n   *\n   * @default none\n   */\n  deprecated?: string;\n\n  /**\n   * The `@returns` block for this doc comment, or undefined if there is not\n   * one.\n   *\n   * @default none\n   */\n  returns?: string;\n\n  /**\n   * Whether the API item is beta/experimental quality\n   */\n  stability?: Stability;\n\n  /**\n   * Example showing the usage of this API item\n   *\n   * Starts off in running text mode, may switch to code using fenced code\n   * blocks.\n   *\n   * @default none\n   */\n  example?: string;\n\n  /**\n   * A `@see` link with more information\n   *\n   * @default none\n   */\n  see?: string;\n\n  /**\n   * Whether this class or interface was intended to be subclassed/implemented\n   * by library users.\n   *\n   * Classes intended for subclassing, and interfaces intended to be\n   * implemented by consumers, are held to stricter standards of API\n   * compatibility.\n   *\n   * @default false\n   */\n  subclassable?: boolean;\n\n  /**\n   * Description of the default\n   *\n   * @default none\n   */\n  default?: string;\n\n  /**\n   * Custom tags that are not any of the default ones\n   *\n   * @default none\n   */\n  custom?: { [tag: string]: string };\n}\n\n/**\n * API Stability levels. These are modeled after the `node` stability index.\n *\n * @see https://nodejs.org/api/documentation.html#documentation_stability_index.\n */\nexport enum Stability {\n  /**\n   * The API may emit warnings. Backward compatibility is not guaranteed.\n   *\n   * More information about the deprecation can usually be found in the\n   * `deprecated` field.\n   */\n  Deprecated = 'deprecated',\n\n  /**\n   * This API is still under active development and subject to non-backward\n   * compatible changes or removal in any future version. Use of the API is\n   * not recommended in production environments. Experimental APIs are not\n   * subject to the Semantic Versioning model.\n   */\n  Experimental = 'experimental',\n\n  /**\n   * This API is subject to the Semantic Versioning model and may not change\n   * in breaking ways in a subsequent minor or patch version.\n   */\n  Stable = 'stable',\n\n  /**\n   * This API is an representation of an API managed elsewhere and follows\n   * the other API's versioning model.\n   */\n  External = 'external',\n}\n\n/**\n * Indicates that an entity is documentable.\n */\nexport interface Documentable {\n  /**\n   * Documentation for this entity.\n   *\n   * @default none\n   */\n  docs?: Docs;\n}\n\n/**\n * Indicates that an entity has a source location\n */\nexport interface SourceLocatable {\n  /**\n   * Where in the module this definition was found\n   *\n   * Why is this not `locationInAssembly`? Because the assembly is the JSII\n   * file combining compiled code and its manifest, whereas this is referring\n   * to the location of the source in the module the assembly was built from.\n   *\n   * @default none\n   */\n  locationInModule?: SourceLocation;\n}\n\n/**\n * Indicates that a jsii entity's origin can be traced to TypeScript code\n *\n * This is interface is not the same as `SourceLocatable`. SourceLocatable\n * identifies lines in source files in a source repository (in a `.ts` file,\n * with respect to a git root).\n *\n * On the other hand, `TypeScriptLocatable` identifies a symbol name inside a\n * potentially distributed TypeScript file (in either a `.d.ts` or `.ts`\n * file, with respect to the package root).\n */\nexport interface TypeScriptLocatable {\n  /**\n   * Unique string representation of the corresponding Typescript symbol\n   *\n   * Used to map from TypeScript code back into the assembly.\n   */\n  symbolId?: string;\n}\n\n/**\n * Kinds of collections.\n */\nexport enum CollectionKind {\n  /**\n   * An array, or a list of some element type.\n   */\n  Array = 'array',\n  /**\n   * A map of a string to some element type.\n   */\n  Map = 'map',\n}\n\n/**\n * Kinds of primitive types.\n */\nexport enum PrimitiveType {\n  /**\n   * A JSON date (represented as it's ISO-8601 string form).\n   */\n  Date = 'date',\n\n  /**\n   * A plain string.\n   */\n  String = 'string',\n\n  /**\n   * A number (integer or float).\n   */\n  Number = 'number',\n\n  /**\n   * A boolean value.\n   */\n  Boolean = 'boolean',\n\n  /**\n   * A JSON object\n   */\n  Json = 'json',\n\n  /**\n   * Value with \"any\" or \"unknown\" type (aka Object). Values typed `any` may\n   * be `null` or `undefined`.\n   */\n  Any = 'any',\n}\n\n/**\n * A value that can possibly be optional.\n */\nexport interface OptionalValue {\n  /**\n   * Determines whether the value is, indeed, optional.\n   *\n   * @default false\n   */\n  optional?: boolean;\n\n  /**\n   * The declared type of the value, when it's present.\n   */\n  type: TypeReference;\n}\n\n/**\n * A reference to a type (primitive, collection or fqn).\n */\nexport type TypeReference =\n  | NamedTypeReference\n  | PrimitiveTypeReference\n  | CollectionTypeReference\n  | UnionTypeReference;\n\n/**\n * The standard representation of the `any` type (includes optionality marker).\n */\nexport const CANONICAL_ANY: Readonly<PrimitiveTypeReference> = {\n  primitive: PrimitiveType.Any,\n};\n\n/**\n * Reference to a named type, defined by this assembly or one of its\n * dependencies.\n */\nexport interface NamedTypeReference {\n  /**\n   * The fully-qualified-name of the type (can be located in the\n   * ``spec.types[fqn]``` of the assembly that defines the type).\n   */\n  fqn: FQN;\n}\nexport function isNamedTypeReference(\n  ref: TypeReference | undefined,\n): ref is NamedTypeReference {\n  return !!(ref as NamedTypeReference)?.fqn;\n}\n\n/**\n * Reference to a primitive type.\n */\nexport interface PrimitiveTypeReference {\n  /**\n   * If this is a reference to a primitive type, this will include the\n   * primitive type kind.\n   */\n  primitive: PrimitiveType;\n}\nexport function isPrimitiveTypeReference(\n  ref: TypeReference | undefined,\n): ref is PrimitiveTypeReference {\n  return !!(ref as PrimitiveTypeReference)?.primitive;\n}\n\n/**\n * Reference to a collection type.\n */\nexport interface CollectionTypeReference {\n  collection: {\n    /**\n     * The kind of collection.\n     */\n    kind: CollectionKind;\n\n    /**\n     * The type of an element (map keys are always strings).\n     */\n    elementtype: TypeReference;\n  };\n}\nexport function isCollectionTypeReference(\n  ref: TypeReference | undefined,\n): ref is CollectionTypeReference {\n  return !!(ref as CollectionTypeReference)?.collection;\n}\n\n/**\n * Reference to a union type.\n */\nexport interface UnionTypeReference {\n  /**\n   * Indicates that this is a union type, which means it can be one of a set\n   * of types.\n   */\n  union: {\n    /**\n     * All the possible types (including the primary type).\n     *\n     * @minItems 2\n     */\n    types: TypeReference[];\n  };\n}\nexport function isUnionTypeReference(\n  ref: TypeReference | undefined,\n): ref is UnionTypeReference {\n  return !!(ref as UnionTypeReference)?.union;\n}\n\n/**\n * Methods and properties can be overridden from parent classes or implemented\n * from interfaces.\n */\nexport interface Overridable {\n  /**\n   * The FQN of the parent type (class or interface) that this entity\n   * overrides or implements. If undefined, then this entity is the first in\n   * it's hierarchy to declare this entity.\n   *\n   * @default this member is not overriding anything\n   */\n  overrides?: FQN;\n}\n\n/**\n * A class property.\n */\nexport interface Property\n  extends Documentable,\n    OptionalValue,\n    Overridable,\n    SourceLocatable {\n  /**\n   * The name of the property.\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * Indicates if this property only has a getter (immutable).\n   *\n   * @default false\n   */\n  immutable?: boolean;\n\n  /**\n   * Indicates if this property is protected (otherwise it is public)\n   *\n   * @default false\n   */\n  protected?: boolean;\n\n  /**\n   * Indicates if this property is abstract\n   *\n   * @default false\n   */\n  abstract?: boolean;\n\n  /**\n   * Indicates if this is a static property.\n   *\n   * @default false\n   */\n  static?: boolean;\n\n  /**\n   * A hint that indicates that this static, immutable property is initialized\n   * during startup. This allows emitting \"const\" idioms in different target\n   * languages. Implies `static` and `immutable`.\n   *\n   * @default false\n   */\n  const?: boolean;\n}\n\n/**\n * Represents a method parameter.\n */\nexport interface Parameter extends Documentable, OptionalValue {\n  /**\n   * The name of the parameter.\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * Whether this is the last parameter of a variadic method. In such cases,\n   * the `#type` attribute is the type of each individual item of the variadic\n   * arguments list (as opposed to some array type, as for example TypeScript\n   * would model it).\n   *\n   * @default false\n   */\n  variadic?: boolean;\n}\n\n/**\n * An Initializer or a Method.\n */\nexport interface Callable extends Documentable, Overridable, SourceLocatable {\n  /**\n   * The parameters of the Initializer or Method.\n   *\n   * @default none\n   */\n  parameters?: Parameter[];\n\n  /**\n   * Indicates if this Initializer or Method is protected (otherwise it is\n   * public, since private members are not modeled).\n   *\n   * @default false\n   */\n  protected?: boolean;\n\n  /**\n   * Indicates whether this Initializer or Method is variadic or not. When\n   * ``true``, the last element of ``#parameters`` will also be flagged\n   * ``#variadic``.\n   *\n   * @default false\n   */\n  variadic?: boolean;\n}\n\n/**\n * An initializer.\n */\nexport type Initializer = Callable;\n\n/**\n * A method with a name (i.e: not an initializer).\n */\nexport interface Method extends Callable {\n  /**\n   * The name of the method. Undefined if this method is a initializer.\n   */\n  name: string;\n\n  /**\n   * The return type of the method (`undefined` if `void`)\n   *\n   * @default void\n   */\n  returns?: OptionalValue;\n\n  /**\n   * Is this method an abstract method (this means the class will also be an abstract class)\n   *\n   * @default false\n   */\n  abstract?: boolean;\n\n  /**\n   * Indicates if this is an asynchronous method (it will return a promise).\n   *\n   * @default false\n   */\n  async?: boolean;\n\n  /**\n   * Indicates if this is a static method.\n   *\n   * @default false\n   */\n  static?: boolean;\n}\n/**\n * Determines whether a Callable is a Method or not.\n *\n * @param callable the callable to be checked.\n */\nexport function isMethod(callable: Callable): callable is Method {\n  return !!(callable as Method).name;\n}\n\n/**\n * Represents a type definition (not a type reference).\n */\nexport type Type = TypeBase & (ClassType | EnumType | InterfaceType);\n\n/**\n * Common attributes of a type definition.\n */\nexport interface TypeBase\n  extends Documentable,\n    SourceLocatable,\n    TypeScriptLocatable {\n  /**\n   * The fully qualified name of the type (``<assembly>.<namespace>.<name>``)\n   *\n   * @minLength 3\n   */\n  fqn: FQN;\n\n  /**\n   * The name of the assembly the type belongs to.\n   *\n   * @minLength 1\n   */\n  assembly: string;\n\n  /**\n   * The namespace of the type (`foo.bar.baz`).\n   *\n   * When undefined, the type is located at the root of the assembly (its\n   * `fqn` would be like `<assembly>.<name>`).\n   *\n   * For types inside other types or inside submodules, the `<namespace>` corresponds to\n   * the namespace-qualified name of the container (can contain multiple segments like:\n   * `<ns1>.<ns2>.<ns3>`).\n   *\n   * In all cases:\n   *\n   *  <fqn> = <assembly>[.<namespace>].<name>\n   *\n   * @default none\n   */\n  namespace?: string;\n\n  /**\n   * The simple name of the type (MyClass).\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * The kind of the type.\n   */\n  kind: TypeKind;\n}\n\n/**\n * Kinds of types.\n */\nexport enum TypeKind {\n  Class = 'class',\n  Enum = 'enum',\n  Interface = 'interface',\n}\n\n/**\n * Represents classes.\n */\nexport interface ClassType extends TypeBase {\n  kind: TypeKind.Class;\n\n  /**\n   * The FQN of the base class of this class, if it has one.\n   *\n   * @default no base class\n   */\n  base?: FQN;\n\n  /**\n   * Initializer (constructor) method.\n   *\n   * @default no initializer\n   */\n  initializer?: Initializer;\n\n  /**\n   * List of properties.\n   *\n   * @default none\n   */\n  properties?: Property[];\n\n  /**\n   * List of methods.\n   *\n   * @default none\n   */\n  methods?: Method[];\n\n  /**\n   * Indicates if this class is an abstract class.\n   *\n   * @default false\n   */\n  abstract?: boolean;\n\n  /**\n   * The FQNs of the interfaces this class implements, if any.\n   *\n   * @default none\n   * @uniqueItems true\n   */\n  interfaces?: FQN[];\n}\n\nexport function isClassType(type: Type | undefined): type is ClassType {\n  return type?.kind === TypeKind.Class;\n}\n\nexport interface InterfaceType extends TypeBase {\n  kind: TypeKind.Interface;\n\n  /**\n   * The FQNs of the interfaces this interface extends, if any.\n   *\n   * @default none\n   * @uniqueItems true\n   */\n  interfaces?: FQN[];\n\n  /**\n   * List of methods.\n   *\n   * @default none\n   */\n  methods?: Method[];\n\n  /**\n   * List of properties.\n   *\n   * @default none\n   */\n  properties?: Property[];\n\n  /**\n   * True if this interface only contains properties. Different backends might\n   * have idiomatic ways to allow defining concrete instances such interfaces.\n   * For example, in Java, the generator will produce a PoJo and a builder\n   * which will allow users to create a concrete object with data which\n   * adheres to this interface.\n   *\n   * @default false\n   */\n  datatype?: boolean;\n}\n\nexport function isInterfaceType(type: Type | undefined): type is InterfaceType {\n  return type?.kind === TypeKind.Interface;\n}\n\n/**\n * Represents a member of an enum.\n */\nexport interface EnumMember extends Documentable {\n  /**\n   * The name/symbol of the member.\n   */\n  name: string;\n}\n\n/**\n * Represents an enum type.\n */\nexport interface EnumType extends TypeBase {\n  kind: TypeKind.Enum;\n\n  /**\n   * Members of the enum.\n   */\n  members: EnumMember[];\n}\n\nexport function isEnumType(type: Type | undefined): type is EnumType {\n  return type?.kind === TypeKind.Enum;\n}\n\n/**\n * Return whether this type is a class or interface type\n */\nexport function isClassOrInterfaceType(\n  type: Type | undefined,\n): type is InterfaceType | ClassType {\n  return isClassType(type) || isInterfaceType(type);\n}\n\n/**\n * Return a string representation of the given type reference.\n */\nexport function describeTypeReference(type?: TypeReference): string {\n  if (type === undefined) {\n    return 'void';\n  }\n\n  if (isNamedTypeReference(type)) {\n    return type.fqn;\n  }\n\n  if (isPrimitiveTypeReference(type)) {\n    return type.primitive;\n  }\n\n  if (isCollectionTypeReference(type)) {\n    return `${type.collection.kind}<${describeTypeReference(\n      type.collection.elementtype,\n    )}>`;\n  }\n\n  if (isUnionTypeReference(type)) {\n    const unionType = type.union.types.map(describeTypeReference).join(' | ');\n    return unionType;\n  }\n\n  throw new Error('Unrecognized type reference');\n}\n\n/**\n * Determines whether an entity is deprecated.\n *\n * @param entity the entity to be checked.\n *\n * @returns true if the entity is marked as deprecated.\n */\nexport function isDeprecated(entity: Documentable): boolean {\n  return entity?.docs?.stability === Stability.Deprecated;\n}\n","export * from './assembly';\nexport * from './assembly-utils';\nexport * from './configuration';\nexport * from './name-tree';\nexport * from './redirect';\nexport * from './validate-assembly';\n","import * as spec from './assembly';\n\n/**\n * A tree of all names in a module. A node represent a type (terminal)\n * and may represent another node in the namespace (at the same time).\n * Therefore, a key of '_' represents a terminal and references the fqn\n * of the type.\n *\n * For example, say we have the following types:\n *   - aws.ec2.Host\n *   - aws.ec2.Instance\n *   - aws.ec2.Instance.Subtype\n *\n * the the name tree will look like this:\n *\n * module: {\n *   children: {\n *     aws: {\n *       children {\n *         ec2: {\n *           children: {\n *             Host: {\n *               fqn: 'aws.ec2.Host',\n *               children: {}\n *             },\n *             Instance: {\n *               fqn: 'aws.ec2.Host',\n *               children: {\n *                 Subtype: {\n *                   fqn: 'aws.ec2.Host.Subtype',\n *                   children: {}\n *                 }\n *               }\n *             }\n *           }\n *         }\n *       }\n *     }\n *   }\n * }\n */\nexport class NameTree {\n  public static of(assm: spec.Assembly): NameTree {\n    const nameTree = new NameTree();\n    for (const type of Object.values(assm.types ?? {})) {\n      nameTree.register(type.fqn);\n    }\n    return nameTree;\n  }\n\n  private _children: { [name: string]: NameTree } = {};\n  private _fqn?: string;\n\n  /* NameTree.of(assembly) should be used. */\n  private constructor() {}\n\n  /** The children of this node, by name. */\n  public get children(): { readonly [name: string]: NameTree } {\n    return this._children;\n  }\n\n  /** The fully qualified name of the type at this node, if there is one. */\n  public get fqn(): string | undefined {\n    return this._fqn;\n  }\n\n  /**\n   * Adds a type to this ``NameTree``.\n   *\n   * @param type the type to be added.\n   * @param path the path at which to add the node under this tree.\n   */\n  private register(fqn: string, path: string[] = fqn.split('.')): this {\n    if (path.length === 0) {\n      this._fqn = fqn;\n    } else {\n      const [head, ...rest] = path;\n      if (!this._children[head]) {\n        this._children[head] = new NameTree();\n      }\n      this._children[head]!.register(fqn, rest);\n    }\n    return this;\n  }\n}\n","import Ajv from 'ajv';\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\nexport const assemblyRedirectSchema = require('../schema/assembly-redirect.schema.json');\n\nconst SCHEMA = 'jsii/file-redirect';\n\nexport interface AssemblyRedirect {\n  readonly schema: typeof SCHEMA;\n\n  /**\n   * The compression applied to the target file, if any.\n   */\n  readonly compression?: 'gzip';\n\n  /**\n   * The name of the file the assembly is redirected to.\n   */\n  readonly filename: string;\n}\n\n/**\n * Checks whether the provided value is an assembly redirect. This only checks\n * for presence of the correct value in the `schema` attribute. For full\n * validation, `validateAssemblyRedirect` should be used instead.\n *\n * @param obj the value to be tested.\n *\n * @returns `true` if the value is indeed an AssemblyRedirect.\n */\nexport function isAssemblyRedirect(obj: unknown): obj is AssemblyRedirect {\n  if (typeof obj !== 'object' || obj == null) {\n    return false;\n  }\n  return (obj as any).schema === SCHEMA;\n}\n\n/**\n * Validates the provided value as an assembly redirect.\n *\n * @param obj the value to be tested.\n *\n * @returns the validated value.\n */\nexport function validateAssemblyRedirect(obj: unknown): AssemblyRedirect {\n  const ajv = new Ajv();\n  const validate = ajv.compile(assemblyRedirectSchema);\n  validate(obj);\n\n  if (validate.errors) {\n    throw new Error(\n      `Invalid assembly redirect:\\n${validate.errors\n        .map((e) => ` * ${e.message}`)\n        .join('\\n')\n        .toString()}`,\n    );\n  }\n\n  return obj as AssemblyRedirect;\n}\n","import Ajv from 'ajv';\n\nimport { Assembly } from './assembly';\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\nexport const schema = require('../schema/jsii-spec.schema.json');\n\nexport function validateAssembly(obj: any): Assembly {\n  const ajv = new Ajv();\n  const validate = ajv.compile(schema);\n  validate(obj);\n\n  if (validate.errors) {\n    throw new Error(\n      `Invalid assembly:\\n${validate.errors\n        .map((e) => ` * ${e.message}`)\n        .join('\\n')\n        .toString()}`,\n    );\n  }\n  return obj;\n}\n","import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  it.dataTypes = it.dataTypes.filter((t) => includesType(types, t))\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"module\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as packageInfo from '../package.json';\nimport { KernelHost } from './host';\nimport { InputOutput } from './in-out';\nimport { SyncStdio } from './sync-stdio';\n\nconst name = packageInfo.name;\nconst version = packageInfo.version;\n\nconst noStack = !!process.env.JSII_NOSTACK;\nconst debug = !!process.env.JSII_DEBUG;\nconst debugTiming = !!process.env.JSII_DEBUG_TIMING;\n\n// This assumes FD#3 is opened for reading and writing. This is normally\n// performed by`bin/jsii-runtime.js`, and we will not be verifying this once\n// again...Meaning that failure to have set this up correctly results in\n// undefined behavior(likely a crash).\nconst stdio = new SyncStdio({\n  // \"process.stderr.fd\" is not in @types/node definitions because it can be\n  // absent in certain circumstances (for example, in `worker_threads` workers).\n  // We'll fall-back to `2` - its expected value - in this case; but this is not\n  // supposed to be happening here (we don't use `worker_threads`).\n  errorFD: (process.stderr as any).fd ?? 2,\n  readFD: 3,\n  writeFD: 3,\n});\n\nconst inout = new InputOutput(stdio);\nconst host = new KernelHost(inout, { debug, noStack, debugTiming });\n\nhost.once('exit', process.exit.bind(process));\n\n// say hello\ninout.write({ hello: `${name}@${version}` });\ninout.debug = debug; // we don't want \"hello\" emitted\n\nhost.run();\n"],"names":["fs","path","LCHOWN","lchown","LCHOWNSYNC","lchownSync","needEISDIRHandled","process","version","match","uid","gid","er","code","handleEISDIR","cb","chown","_","__","___","handleEISDirSync","chownSync","nodeVersion","readdir","options","test","cpath","chownrKid","p","child","lstat","resolve","stats","name","isDirectory","chownr","withFileTypes","children","length","len","errState","then","forEach","chownrSync","readdirSync","lstatSync","chownrKidSync","module","exports","sync","equal","a","b","constructor","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","mkdirsSync","utimesMillisSync","stat","getStats","destStat","src","dest","opts","srcStat","dereference","statSync","copyDir","srcMode","mkdirSync","setDestMode","mkDirAndCopy","mode","onDir","isFile","isCharacterDevice","isBlockDevice","overwrite","unlinkSync","copyFile","errorOnExist","Error","mayCopyFile","onFile","isSymbolicLink","resolvedSrc","readlinkSync","cwd","resolvedDest","err","symlinkSync","isSrcSubdir","copyLink","onLink","isSocket","isFIFO","copyFileSync","preserveTimestamps","fileIsNotWritable","makeFileWritable","updatedSrcStat","atime","mtime","setDestTimestamps","handleTimestamps","chmodSync","item","srcItem","join","destItem","checkPathsSync","filter","startCopy","copyDirItem","clobber","arch","emitWarning","checkParentPathsSync","destParent","dirname","existsSync","handleFilterAndCopy","mkdirs","pathExists","utimesMillis","checkParentDir","dirExists","handleFilter","onInclude","Promise","include","error","mkdir","unlink","setDestTimestampsAndMode","handleTimestampsAndMode","chmod","items","copyDirItems","pop","checkPaths","readlink","symlink","checkParentPaths","u","copy","copySync","remove","emptyDir","async","dir","all","map","emptyDirSync","removeSync","emptydirSync","emptydir","createFile","file","callback","makeFile","writeFile","createFileSync","writeFileSync","ensureFile","ensureFileSync","createLink","createLinkSync","ensureLink","ensureLinkSync","createSymlink","createSymlinkSync","ensureSymlink","ensureSymlinkSync","srcpath","dstpath","makeLink","link","dstStat","message","replace","areIdentical","linkSync","symlinkPaths","isAbsolute","toCwd","toDst","dstdir","relativeToDst","exists","relative","symlinkPathsSync","symlinkType","type","symlinkTypeSync","_mkdirs","_symlinkPaths","_symlinkType","_createSymlink","api","assign","method","filename","read","fd","buffer","offset","position","reject","bytesRead","write","args","bytesWritten","writev","buffers","realpath","native","jsonFile","outputJson","outputJsonSync","outputJSON","outputJSONSync","writeJSON","writeJson","writeJSONSync","writeJsonSync","readJSON","readJson","readJSONSync","readJsonSync","readFile","readFileSync","data","str","stringify","outputFileSync","outputFile","makeDir","_makeDir","makeDirSync","mkdirp","mkdirpSync","ensureDir","ensureDirSync","getMode","checkPath","recursive","pth","platform","parse","root","move","moveSync","rename","renameSync","moveAcrossDevice","parent","isParentRoot","isChangingCase","doRename","destExists","encoding","itDoes","access","catch","pathExistsSync","rimraf","rm","force","rmSync","assert","isWindows","defaults","m","maxBusyTries","busyTries","strictEqual","rimraf_","CB","setTimeout","st","fixWinEPERM","rmdir","er2","er3","fixWinEPERMSync","rmdirSync","originalEr","files","n","f","rmkids","rimrafSync","startTime","Date","now","rmkidsSync","util","statFunc","bigint","ino","dev","srcArr","split","sep","destArr","reduce","acc","cur","errMsg","funcName","callbackify","srcBaseName","basename","destBaseName","toLowerCase","getStatsSync","srcParent","open","futimes","futimesErr","close","closeErr","openSync","futimesSync","closeSync","MiniPass","EE","binding","FSReqWrap","FSReqCallback","iovec","pos","req","oncomplete","bw","writeBuffers","_autoClose","Symbol","_close","_ended","_fd","_finished","_flags","_flush","_handleChunk","_makeBuf","_mode","_needDrain","_onerror","_onopen","_onread","_onwrite","_open","_path","_pos","_queue","_read","_readSize","_reading","_remain","_size","_write","_writing","_defaultFlag","_errored","ReadStream","opt","super","this","readable","writable","TypeError","readSize","size","Infinity","autoClose","end","emit","Buffer","allocUnsafe","Math","min","buf","nextTick","br","ret","slice","ev","WriteStream","undefined","start","defaultFlag","enc","from","push","ReadStreamSync","threw","readSync","WriteStreamSync","writeSync","obj","__proto__","getPrototypeOf","create","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","gracefulQueue","previousSymbol","polyfills","legacy","clone","publishQueue","context","queue","get","for","retryTimer","debug","debuglog","env","NODE_DEBUG","format","apply","arguments","console","global","fs$close","resetQueue","value","fs$closeSync","on","patch","gracefulify","createReadStream","createWriteStream","fs$readFile","go$readFile","enqueue","fs$writeFile","go$writeFile","fs$appendFile","appendFile","go$appendFile","fs$copyFile","go$copyFile","fs$readdir","go$readdir","noReaddirOptionVersions","fs$readdirCallback","sort","substr","legStreams","fs$ReadStream","that","destroy","fs$WriteStream","set","val","enumerable","configurable","FileReadStream","FileWriteStream","fs$open","go$open","elem","retry","clearTimeout","shift","fn","lastTime","sinceAttempt","sinceStart","max","concat","TEST_GRACEFUL_FS_GLOBAL_PATCH","__patched","Stream","self","paused","bufferSize","index","setEncoding","busy","flush","constants","origCwd","GRACEFUL_FS_PLATFORM","chdir","d","setPrototypeOf","lchmod","O_WRONLY","O_SYMLINK","fchmod","err2","lchmodSync","fchmodSync","patchLchmod","lutimes","at","mt","lutimesSync","_a","_b","_c","patchLutimes","chownFix","fchown","chmodFix","chownFixSync","fchownSync","chmodFixSync","statFix","fstat","statFixSync","fstatSync","fs$rename","to","backoff","stater","orig","target","chownErOk","getuid","fs$read","callback_","eagCounter","fs$readSync","_fs","universalify","jsonfile","fromPromise","shouldThrow","throws","fromCallback","stripBom","JSON","reviver","content","EOF","finalEOL","EOL","replacer","spaces","isBuffer","wx","c","O_TRUNC","O_CREAT","O_EXCL","os","filetime","msg","pid","locks","onExit","unlockSync","H","listeners","h","e","removeListener","unlock","unlinkEr","check","stale","age","getTime","checkSync","wait","maybeStale","hasStaleLock","statEr","lock","notStale","pollPeriod","retryThrow","retries","newRT","lockSync","retryWait","ct","ceil","proc","stdout","stderr","SD","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","EMITDATA","EMITEND","EMITEND2","ASYNC","defer","doIter","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","Pipe","ondrain","unpipe","proxyErrors","PipeProxyErrors","Minipass","pipes","objectMode","bufferLength","lastNeed","chunk","om","ArrayBuffer","isView","byteOffset","byteLength","isArrayBuffer","flowing","once","resume","pause","destroyed","noDrain","pipe","ended","find","splice","indexOf","addListener","isEndish","removeAllListeners","emittedEnd","extra","collect","dataLength","promise","next","res","done","onerr","ondata","onend","ondestroy","rej","static","s","realZlibConstants","ZLIB_VERNUM","freeze","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","DEFLATE","INFLATE","GZIP","GUNZIP","DEFLATERAW","INFLATERAW","UNZIP","BROTLI_DECODE","BROTLI_ENCODE","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","Z_DEFAULT_WINDOWBITS","Z_MIN_CHUNK","Z_MAX_CHUNK","Z_DEFAULT_CHUNK","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","Z_DEFAULT_MEMLEVEL","Z_MIN_LEVEL","Z_MAX_LEVEL","Z_DEFAULT_LEVEL","BROTLI_OPERATION_PROCESS","BROTLI_OPERATION_FLUSH","BROTLI_OPERATION_FINISH","BROTLI_OPERATION_EMIT_METADATA","BROTLI_MODE_GENERIC","BROTLI_MODE_TEXT","BROTLI_MODE_FONT","BROTLI_DEFAULT_MODE","BROTLI_MIN_QUALITY","BROTLI_MAX_QUALITY","BROTLI_DEFAULT_QUALITY","BROTLI_MIN_WINDOW_BITS","BROTLI_MAX_WINDOW_BITS","BROTLI_LARGE_MAX_WINDOW_BITS","BROTLI_DEFAULT_WINDOW","BROTLI_MIN_INPUT_BLOCK_BITS","BROTLI_MAX_INPUT_BLOCK_BITS","BROTLI_PARAM_MODE","BROTLI_PARAM_QUALITY","BROTLI_PARAM_LGWIN","BROTLI_PARAM_LGBLOCK","BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING","BROTLI_PARAM_SIZE_HINT","BROTLI_PARAM_LARGE_WINDOW","BROTLI_PARAM_NPOSTFIX","BROTLI_PARAM_NDIRECT","BROTLI_DECODER_RESULT_ERROR","BROTLI_DECODER_RESULT_SUCCESS","BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT","BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT","BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION","BROTLI_DECODER_PARAM_LARGE_WINDOW","BROTLI_DECODER_NO_ERROR","BROTLI_DECODER_SUCCESS","BROTLI_DECODER_NEEDS_MORE_INPUT","BROTLI_DECODER_NEEDS_MORE_OUTPUT","BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE","BROTLI_DECODER_ERROR_FORMAT_RESERVED","BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE","BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET","BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME","BROTLI_DECODER_ERROR_FORMAT_CL_SPACE","BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE","BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT","BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1","BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2","BROTLI_DECODER_ERROR_FORMAT_TRANSFORM","BROTLI_DECODER_ERROR_FORMAT_DICTIONARY","BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS","BROTLI_DECODER_ERROR_FORMAT_PADDING_1","BROTLI_DECODER_ERROR_FORMAT_PADDING_2","BROTLI_DECODER_ERROR_FORMAT_DISTANCE","BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET","BROTLI_DECODER_ERROR_INVALID_ARGUMENTS","BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES","BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS","BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP","BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1","BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2","BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES","BROTLI_DECODER_ERROR_UNREACHABLE","realZlib","OriginalBufferConcat","_superWrite","ZlibError","errno","captureStackTrace","_opts","_flushFlag","_finishFlushFlag","_fullFlushFlag","_handle","_onError","_sawError","_level","_strategy","ZlibBase","finishFlush","reset","flushFlag","alloc","nativeHandle","originalNativeClose","originalClose","result","writeReturn","_processChunk","Zlib","level","strategy","params","origFlush","_portable","Brotli","BrotliCompress","BrotliDecompress","Deflate","Inflate","Gzip","portable","Gunzip","DeflateRaw","InflateRaw","Unzip","optsArg","pathArg","useNative","mkdirpNative","mkdirpManual","useNativeSync","mkdirpNativeSync","mkdirpManualSync","manual","nativeSync","manualSync","findMade","statAsync","findMadeSync","made","mkdirAsync","parseInt","promisify","__TESTING_MKDIRP_PLATFORM__","badWinChars","versArr","__TESTING_MKDIRP_NODE_VERSION__","hasNative","processOk","reallyExit","kill","emitter","signals","isWin","EventEmitter","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","loaded","load","alwaysLast","unload","sig","sigListeners","originalProcessEmit","originalProcessReallyExit","event","signal","processEmit","processReallyExit","exitCode","arg","r","t","list","update","x","extract","Pack","Unpack","Parse","ReadEntry","WriteEntry","Header","Pax","types","hlo","fsm","opt_","createSync","Sync","stream","addFilesSync","addFilesAsync","charAt","noResume","onentry","entry","add","stripSlash","filesFilter","extractFileSync","extractFile","extractSync","Map","mapHas","has","maxReadSize","__FAKE_PLATFORM__","__FAKE_TESTING_FS__","fMapEnabled","UV_FS_O_FILEMAP","fMapFlag","pathModule","large","SLURP","TYPE","splitPrefix","prefixSize","pp","prefix","pathSize","decString","off","decDate","numToDate","decNumber","num","decSmallNumber","nanNull","trim","isNaN","MAXNUM","encNumber","number","encode","encSmallNumber","octalString","padOctal","floor","string","encDate","date","NULLS","encString","ex","gex","cksumValid","needPax","nullBlock","block","cksum","linkpath","uname","gname","devmaj","devmin","ctime","decode","sum","k","charCodeAt","typeKey","argmap","kv","encodePositive","encodeNegative","flipped","byte","onesComp","twosComp","twos","pow","Number","isSafeInteger","pre","Parser","onentryFunction","listFileSync","listFile","normPath","SymlinkError","CwdError","cGet","cache","cSet","umask","needChmod","doChown","processUid","processGid","preserve","created","checkCwd","parts","mkdir_","base","part","onmkdir","ok","checkCwdSync","isDir","normalizeCache","normalize","TESTING_TAR_FAKE_PLATFORM","PackJob","absolute","pending","ignore","piped","zlib","WriteEntrySync","WriteEntryTar","Tar","Yallist","ONSTAT","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","warner","preservePaths","strict","noPax","linkCache","statCache","readdirCache","onwarn","zip","gzip","noDirRecurse","follow","noMtime","jobs","job","entries","w","head","removeNode","warn","Entry","gzipHeader","STATE","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","BUFFER","EMITTEDEND","EMIT","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","ABORTED","DONE","SAW_VALID_ENTRY","SAW_NULL_BLOCK","SAW_EOF","noop","ondone","maxMetaEntrySize","header","remain","invalid","meta","go","re","blockRemain","abort","recoverable","have","stripSlashes","queues","reservations","running","Set","paths","dirs","getQueues","every","q","run","clear","delete","reserve","getDirs","charset","comment","nlink","body","encodeBody","bodyLen","bufLen","encodeField","field","byteLen","digits","log","g","merge","parseKV","parseKVLine","line","v","extended","globalExtended","startBlockSize","writeLen","replaceSync","headBuf","POSITION","bufPos","bytes","entryBlockSize","mtimeCache","streamSync","flag","onopen","cb_","onread","getPos","parsed","slashesStart","wc","pathReservations","stripAbsolutePath","ONENTRY","CHECKFS","CHECKFS2","PRUNECACHE","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","CHECKED_CWD","crypto","getFlag","uint32","cacheKeyNormalize","transform","dirCache","preserveOwner","setOwner","getgid","forceChown","win32","newer","keep","strip","processUmask","noChmod","dmode","fmode","linkparts","includes","stripped","resolvedPath","aRoot","pRoot","fullyDone","actions","abs","utimes","tx","unsupported","dropCache","pnorm","pruneCache","afterMakeParent","lstatEr","afterChmod","randomBytes","unlinkFile","callSync","mkParent","unlinkFileSync","oner","closeError","futimeser","utimesSync","utimeser","fchowner","chowner","mtimeFilter","Base","tarCode","raw","win","char","String","fromCharCode","toWin","toRaw","prefixPath","HEADER","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","AWAITDRAIN","PREFIX","HAD_ERROR","winchars","modeFix","myuid","myuser","USER","blockLen","pathWarn","getType","linkKey","syscall","writeBuf","readEntry","sets","xl","subexp","typeOf","o","toUpperCase","toArray","setInterval","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","QUERY$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","maxInt","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","stringFromCharCode","RangeError","array","mapDomain","ucs2decode","output","counter","basicToDigit","codePoint","digitToBasic","digit","adapt","delta","numPoints","firstTime","input","inputLength","bias","basic","lastIndexOf","j","oldi","baseMinusT","out","fromCodePoint","currentValue","basicLength","handledCPCount","handledCPCountPlusOne","qMinusT","toUnicode","toASCII","punycode","SCHEMES","pctEncChar","chr","pctDecChars","newStr","il","c2","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","fragment","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","matches","IPV4ADDRESS","address","_normalizeIPv6","IPV6ADDRESS","zone","reverse","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","longestZeroFields","lastLongest","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","iri","IRI_PROTOCOL","URI_PROTOCOL","reference","port","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","serialize","authority","absolutePath","resolveComponents","tolerant","baseURI","relativeURI","schemelessOptions","uri","uriA","uriB","escapeComponent","ESCAPE","unescapeComponent","handler","secure","http","isSecure","wsComponents","resourceName","ws","O","ATEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","mailtoComponents","unknownHeaders","headers","hfields","hfield","toAddrs","subject","addr","toAddr","atIdx","localPart","domain","URN_PARSE","urnComponents","nid","nss","urnScheme","uriComponents","UUID","uuidComponents","uuid","https","wss","mailto","urn","walker","tail","l","insert","node","inserted","Node","prev","unshift","unshiftNode","pushNode","thisp","forEachReverse","getReverse","mapReverse","initial","reduceReverse","arr","toArrayReverse","sliceReverse","deleteCount","nodes","TOKEN_REF","TOKEN_INTERFACES","TOKEN_DATE","TOKEN_ENUM","TOKEN_MAP","TOKEN_STRUCT","property","comments","hash","createHash","digest","PRUNE_AFTER_MILLISECONDS","JSII_RUNTIME_PACKAGE_CACHE_TTL","DiskCache","pruneExpiredEntries","realpathSync","CACHE","flatMap","ss","entryFor","rawDigest","digestFile","cutOff","lockedEntry","directoriesUnder","inDirectory","markerFile","lockFile","disposed","touch","ignoreErrors","callbackHandler","traceEnabled","debugTimingEnabled","assemblies","objects","ObjectTable","_typeInfoForFqn","bind","cbs","waiting","promises","nextid","_debugTime","_load","_debug","pkgname","pkgver","packageDir","_getPackageDir","epkg","assm","assembly","metadata","originalUmask","extractedTo","tar","tarball","assmSpec","loadAssemblyFromPath","closure","require","Assembly","_addAssembly","invokeBinScript","bin","scriptPath","script","cp","spawnSync","NODE_OPTIONS","execArgv","PATH","execPath","shell","status","_create","del","objref","deleteObject","sget","symbol","fqn","ti","_typeInfoForProperty","_findSymbol","_ensureSync","_fromSandbox","sset","immutable","_toSandbox","findObject","interfaces","propertyToGet","_findPropertyTarget","instance","propInfo","propertyToSet","invoke","_findInvokeTarget","jsiiTypeFqn","_toSandboxValues","parameters","returns","sinvoke","_typeInfoForMethod","begin","syncInProgress","prid","_makeprid","promiseid","storedPromise","callbacks","_req","cbid","cookie","override","complete","fail","sandoxResult","expectedReturnType","succeed","naming","assemblyName","targets","_assemblyFor","objectCount","kind","spec","TypeKind","Interface","Class","Enum","tagJsiiConstructor","_findCtor","wire","EMPTY_OBJECT_FQN","ctor","typeinfo","classType","_validateMethodArguments","initializer","installDir","mkdtempSync","tmpdir","createRequire","requestArgs","ctorResult","registerObject","overrides","overrideTypeErrorMessage","methods","properties","isMethodOverride","isPropertyOverride","_applyMethodOverride","_applyPropertyOverride","_getSuperPropertyName","typeFqn","_tryTypeInfoForMethod","_tryTypeInfoForProperty","CANONICAL_ANY","_defineOverridenProperty","propertyName","getPropertyDescriptor","direct","proto","prevEnumerable","_makecbid","methodInfo","variadic","_defineOverridenMethod","methodName","methodContext","methodArgs","_fromSandboxValues","param","optional","describeTypeReference","curr","moduleName","fqnInfo","addendum","classFqn","bases","found","typeInfo","isClassType","classTypeInfo","isInterfaceType","interfaceTypeInfo","baseFqn","expectedType","findSymbol","lookupType","targetType","xs","_boxUnboxParameters","boxUnbox","parametersCopy","label","fullLabel","time","timeEnd","desc","superProp","existing","destination","OBJID_SYMBOL","IFACES_SYMBOL","JSII_RTTI_SYMBOL","objectReference","resolveType","existingRef","allIfaces","iface","removeRedundant","objid","makeId","privateField","tagObject","additionalInterfaces","builtIn","InterfaceCollection","addFromClass","addFromInterface","removeSyncPaths","registered","onExitHandler","registerIfNeeded","VOID","serializeDate","toISOString","deserializeDate","deserializeEnum","lookup","enumLocator","SerializationError","inspect","typeName","valueName","enumValue","serializationType","typeRef","serializationClass","isPrimitiveTypeReference","primitive","PrimitiveType","Any","Json","Boolean","isCollectionTypeReference","collection","CollectionKind","isUnionTypeReference","compoundTypes","union","order","compareSerializationClasses","isEnumType","datatype","nullAndOk","isDate","isScalar","mapValues","wireValue","propertiesOf","isClassOrInterfaceType","prop","isAssignable","actualTypeFqn","requiredType","actualType","validateRequiredProps","actualProps","specProps","missingRequiredProps","serde","wireTypes","SERIALIZERS","typeDescr","optionalTypeDescr","text","rest","titleize","renderValue","SYMBOL_WIRE_TYPE","_type","deserialize","optionalValue","isWireDate","primitiveType","isWireMap","elementtype","mapJsonValue","toMap","enumType","enumMap","enumEntry","isWireEnum","arrayType","idx","mapType","namedType","props","isObjRef","isWireStruct","jsiiType","namedTypeRef","declaredType","prevRef","descr","isByReferenceOnly","mapOfAny","causes","describeTypeOf","cause","ctorName","HOME","LOCALAPPDATA","packageCacheEnabled","JSII_RUNTIME_PACKAGE_CACHE","toLocaleUpperCase","extractToCache","cacheRoot","JSII_RUNTIME_PACKAGE_CACHE_ROOT","defaultCacheRoot","tmpPath","untarInto","extractToTemporary","inout","kernel","Kernel","eventEmitter","debugTiming","processRequest","setImmediate","exit","listener","completeCallback","completeReq","apiReq","findApi","checkIfAsyncIsAllowed","writeOkay","isPromise","writeError","stack","noStack","apiName","stdio","writeLine","writeErrorLine","reqLine","readLine","startsWith","bufferedData","readBuffer","errorFD","stdin","readFD","writeFD","writeBuffer","newData","newLinePos","compressedAssemblyExists","directory","SPEC_FILE_NAME_COMPRESSED","findAssemblyFile","dotJsiiFile","SPEC_FILE_NAME","writeAssembly","compress","schema","compression","gzipSync","fingerprint","repeat","_fingerprint","failNoReadfileProvided","loadAssemblyFromBuffer","assemblyBuffer","validate","contents","isAssemblyRedirect","followRedirect","validateAssembly","loadAssemblyFromFile","pathToFile","assemblyRedirect","validateAssemblyRedirect","gunzipSync","json","Stability","isNamedTypeReference","ref","SchemaVersion","callable","entity","docs","stability","Deprecated","NameTree","_children","nameTree","values","register","_fqn","assemblyRedirectSchema","compile","META_SUPPORT_DATA","META_SCHEMA_ID","Ajv","_addVocabularies","addVocabulary","discriminator","addKeyword","_addDefaultMetaSchema","metaSchema","$data","$dataMetaSchema","draft7MetaSchema","addMetaSchema","refs","defaultMeta","getSchema","KeywordCxt","nil","Name","CodeGen","_CodeOrName","IDENTIFIER","emptyStr","names","_Code","_items","_str","_names","strs","addCodeArg","plus","expr","safeStringify","mergeExprItems","optimize","c1","rx","strConcat","getProperty","regexpCode","Scope","ValueScope","ValueScopeName","varKinds","operators","GT","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","optimizeNodes","optimizeNames","_constants","Def","varKind","rhs","render","es5","var","_n","optimizeExpr","Assign","lhs","sideEffects","addExprNames","AssignOp","op","Label","Break","Throw","AnyCode","ParentNode","subtractNames","addNames","BlockNode","Root","Else","If","condition","else","cond","ns","not","For","ForLoop","iteration","ForRange","ForIter","loop","iterable","Func","Return","Try","finally","Catch","Finally","replaceName","some","par","extScope","_values","_blockStarts","lines","_extScope","_scope","_nodes","_root","scopeName","scopeValue","prefixOrName","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","toName","_leafNode","const","_constant","let","object","keyValues","if","thenBody","elseBody","_blockNode","endIf","elseIf","_elseNode","_endBlockNode","_for","forBody","endFor","forRange","forOf","forIn","ownProperties","break","return","try","tryBody","catchCode","finallyCode","_currNode","throw","nodeCount","endBlock","toClose","func","funcBody","endFunc","N1","N2","andCode","mappend","orCode","y","ValueError","UsedValueState","_prefixes","prefixes","_parent","_newName","_nameGroup","nameStr","setValue","scopePath","itemIndex","scope","valueKey","vs","_name","_reduceValues","usedValues","getCode","valueCode","nameSet","Started","def","Completed","addError","gen","errObj","vErrors","returnErrors","it","errs","schemaEnv","$async","ValidationError","validateName","keywordError","keyword","keyword$DataError","schemaType","cxt","errorPaths","overrideAllErrors","errorObjectCode","compositeRule","allErrors","errsCount","instancePath","errorPath","errSchemaPath","verbose","schemaValue","E","schemaPath","parentSchema","createErrors","errorInstancePath","errorSchemaPath","messages","topSchemaRef","extraErrorProps","errorObject","instPath","getErrorPath","Type","Str","schPath","SchemaEnv","dynamicAnchors","schemaId","baseId","normalizeId","localRefs","compileSchema","sch","_sch","getCompilingSchema","rootId","getFullPath","uriResolver","_ValidationError","schemaCxt","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","jtd","sourceCode","_compilations","validateFunctionCode","validateCode","Function","makeValidate","scopeValues","unevaluated","evaluated","dynamicProps","dynamicItems","logger","inlineOrCompile","inlineRef","inlineRefs","schEnv","s2","s1","schemas","resolveSchema","refPath","_getFullPath","getJsonPointer","id","schOrRef","schId","resolveUrl","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","partSchema","unescapeFragment","$ref","schemaHasRulesButRef","RULES","valCxt","rootData","jsonPos","jsonLen","jsonPart","MissingRefError","resolver","missingRef","missingSchema","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","eachItem","TRAILING_SLASH_HASH","ANCHOR","baseIds","pathPrefix","schemaRefs","traverse","allKeys","jsonPtr","parentJsonPtr","fullPath","addRef","_resolve","ambiguos","checkAmbiguosRef","addAnchor","anchor","$anchor","$dynamicAnchor","sch1","sch2","jsonTypes","groups","rules","integer","boolean","null","post","keywords","checkUnknownRules","strictSchema","checkStrictMode","schemaHasRules","escapeJsonPointer","unescapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","evaluatedPropsToName","ps","setEvaluated","decodeURIComponent","encodeURIComponent","mergeEvaluated","snippets","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","shouldUseGroup","group","rule","shouldUseRule","definition","implements","kwd","boolError","falseSchemaError","schemaCode","reportError","valid","DataType","getJSONTypes","ts","isJSONType","nullable","coerceTo","coerceTypes","COERCIBLE","coerceToTypes","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","dataType","coerced","coerceSpecificType","reportTypeError","assignParentData","coerceData","checkDataType","strictNums","correct","Correct","numCond","_cond","and","toHash","notObj","typeError","schemaRefOrVal","getTypeErrorContext","assignDefault","defaultValue","childData","useDefaults","ty","default","validateFunction","funcSourceUrl","dynamicRef","destructureValCxtES5","destructureValCxt","subschemaCode","isSchemaObj","checkKeywords","schemaCxtHasRules","$comment","commentKeyword","updateContext","checkAsyncSchema","typeAndKeywords","subSchemaObjCode","boolOrEmptySchema","ignoreKeywordsWithRef","checkRefsAndKeywords","schemaKeywords","getSchemaTypes","coerceAndCheckDataType","rootName","typeErrors","groupKeywords","iterateKeywords","strictTypes","includesType","strictTypesError","checkContextTypes","allowUnionTypes","checkMultipleTypes","hasApplicableType","checkKeywordTypes","checkStrictTypes","keywordCode","assignDefaults","schTs","kwdT","checkNoDefault","resetEvaluated","assignEvaluated","returnResults","topSchemaObjCode","topBoolOrEmptySchema","validateKeywordUsage","getData","validSchemaType","allowUndefined","trackErrors","successAction","failAction","failResult","pass","fail$data","or","invalid$data","append","errorParams","setParams","_error","reportExtraError","$dataError","resetErrorsCount","block$data","codeBlock","$dataValid","check$data","validateSchema","wrong$DataType","validateSchemaRef","invalid$DataSchema","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeValidEvaluated","ruleType","funcKeywordCode","macroKeywordCode","JSON_POINTER","RELATIVE_JSON_POINTER","jsonPointer","exec","up","errorMsg","segments","segment","pointerType","modifyData","useKeyword","macroSchema","macro","schemaRef","checkAsyncKeyword","validateRef","assignValid","_await","passCxt","passContext","passSchema","callValidateCode","modifying","reportErrs","ruleErrs","validateAsync","validateErrs","validateSync","extendErrors","addErrs","deps","dependencies","errorsText","schemaProp","escapeFragment","dpType","dataContextProps","_nextData","jtdDiscriminator","jtdMetadata","defaultRegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","jsonPointers","extendRefs","missingRefs","processCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","ajvErrors","deprecatedOptions","unicode","requiredOptions","_optz","regExp","strictTuples","strictRequired","loopRequired","loopEnum","addUsedSchema","validateFormats","unicodeRegExp","int32range","formats","_loading","_cache","noLogs","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","addInitialKeywords","addInitialSchemas","_dataRefSchema","$dataRefSchema","$id","schemaKeyRef","_meta","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","checkLoaded","loadMissingSchema","_loadSchema","addSchema","_validateSchema","_checkUnique","throwOrLogError","keyRef","getSchEnv","removeSchema","_removeAllSchemas","cacheKey","definitions","kwdOrDef","checkKeyword","addRule","keywordMetaschema","getKeyword","removeKeyword","findIndex","addFormat","dataVar","separator","keywordsJsonPointers","seg","schemaOrData","regex","getSchemaRefs","_compileMetaSchema","currentOpts","checkOpts","optsSchemas","defs","metaOpts","KEYWORD_NAME","ruleGroup","before","addBeforeRule","_rule","$dataRef","anyOf","ucs2length","ajv","validation","validateAdditionalItems","alwaysValidSchema","validateItems","additionalProperty","removeAdditional","allSchemaProperties","patProps","patternProperties","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","definedProp","propsSchema","isOwnProperty","usePattern","isAdditional","schCxt","validateUnion","minContains","maxContains","validateItemsWithCount","schValid","checkLimits","_valid","depsCount","property_ies","missingProperty","propDeps","schDeps","propertyDeps","schemaDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","missing","hasProperty","propertyInData","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","ifClause","hasThen","hasSchema","hasElse","validateIf","validateClause","draft2020","applicator","validateTuple","validateArray","extraItems","schArr","fullTuple","minItems","maxItems","checkStrictTuple","prefixItems","passing","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","checkMatchingProperties","pat","validateProperties","alwaysValid","validatePatternProperties","additionalProperties","allProps","hasDefault","applyPropertySchema","hasPropFunc","noPropertyInData","schemaMap","dataAndSchema","newRegExp","pattern","useFunc","validArr","notValid","core","callRef","callRootRef","schOrEnv","resolveRef","getValidate","callValidate","schName","inlineRefSchema","addErrorsFrom","addEvaluatedFrom","schEvaluated","callAsyncRef","discrError","tagName","DiscrError","Tag","tag","mapping","oneOf","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","required","addMapping","enum","tagValue","getMapping","Mapping","validateMapping","draft7Vocabularies","metadataVocabulary","contentVocabulary","fmts","fDef","fType","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","fmtType","fmtRef","fmtDef","fmt","getFormat","validCondition","validateFormat","useLoop","eql","getEql","vSchema","_x","equalCode","comp","ops","KWDs","maximum","okStr","minimum","exclusiveMaximum","exclusiveMinimum","prec","multipleOfPrecision","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","itemTypes","loopN","indices","loopN2","outer","_traverse","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","skipKeywords","additionalItems","contains","propertyNames","allOf","$defs","multipleOf","maxLength","minLength","maxProperties","minProperties","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","packageInfo","JSII_NOSTACK","JSII_DEBUG","JSII_DEBUG_TIMING","SyncStdio","InputOutput","KernelHost","hello"],"sourceRoot":""}